# Fix 1: Update HybridTimerService.ts for Proper Timer Integration

```typescript
// src/services/HybridTimerService.ts
// Update the addTimeFromGoal method to properly refresh the persistent timer

async addTimeFromGoal(minutes: number): Promise<boolean> {
  try {
    const secondsToAdd = minutes * 60;
    console.log(`üéØ [HybridTimer] Adding ${minutes} minutes (${secondsToAdd}s) from goal completion`);
    
    // Pause overtime if active but don't reset it
    if (this.overtime > 0 && !this.overtimePaused) {
      this.pausedOvertimeValue = this.overtime;
      this.overtimePaused = true;
      console.log(`‚è∏Ô∏è [Timer] Pausing overtime at ${this.overtime}s`);
    }
    
    // Add to time left
    const previousTime = this.timeLeft;
    this.timeLeft += secondsToAdd;
    console.log(`üéØ [HybridTimer] Updated timeLeft: ${previousTime}s -> ${this.timeLeft}s`);
    
    // Update native modules - crucial for persistent notification updates
    let brainBitesSuccess = false;
    let screenTimeSuccess = false;

    // Add to BrainBitesTimer (persistent notifications) - FORCE REFRESH
    try {
      const { BrainBitesTimer } = NativeModules;
      if (BrainBitesTimer) {
        // First add the time
        if (BrainBitesTimer.addTime) {
          await BrainBitesTimer.addTime(secondsToAdd);
          brainBitesSuccess = true;
          console.log(`‚úÖ [HybridTimer] BrainBitesTimer addTime: ${secondsToAdd}s`);
        }
        
        // Force update the persistent notification with new time
        if (BrainBitesTimer.updateTime) {
          await BrainBitesTimer.updateTime(this.timeLeft);
          console.log(`‚úÖ [HybridTimer] BrainBitesTimer updateTime: ${this.timeLeft}s total`);
        }
        
        // Force refresh the notification
        if (BrainBitesTimer.refreshNotification) {
          await BrainBitesTimer.refreshNotification();
          console.log(`‚úÖ [HybridTimer] BrainBitesTimer notification refreshed`);
        }
      }
    } catch (error) {
      console.error('‚ùå [HybridTimer] Failed to add goal time to BrainBitesTimer:', error);
    }

    // Add to ScreenTimeModule (widget support) - FORCE REFRESH
    try {
      const { ScreenTimeModule } = NativeModules;
      if (ScreenTimeModule) {
        if (ScreenTimeModule.addTimeFromGoal) {
          screenTimeSuccess = await ScreenTimeModule.addTimeFromGoal(minutes);
          console.log(`‚úÖ [HybridTimer] ScreenTimeModule addTimeFromGoal: ${minutes}m`);
        }
        
        // Force update widget with new total time
        if (ScreenTimeModule.setScreenTime) {
          const totalMinutes = Math.floor(this.timeLeft / 60);
          await ScreenTimeModule.setScreenTime(totalMinutes);
          console.log(`‚úÖ [HybridTimer] ScreenTimeModule updated to ${totalMinutes}m total`);
        }
      }
    } catch (error) {
      console.error('‚ùå [HybridTimer] Failed to add goal time to ScreenTimeModule:', error);
    }
    
    // Save state and notify listeners
    await this.saveTimerState();
    
    // Update current data
    if (this.currentData) {
      this.currentData = {
        ...this.currentData,
        remainingTime: this.timeLeft,
        overtime: this.overtimePaused ? this.pausedOvertimeValue : this.overtime
      };
    }
    
    // Notify all listeners to refresh UI
    this.notifyListeners();
    
    // Emit event to force UI refresh
    const eventEmitter = new NativeEventEmitter(NativeModules.DeviceEventEmitter || {});
    eventEmitter.emit('timerUpdated', { 
      remainingTime: this.timeLeft,
      addedTime: secondsToAdd,
      source: 'goal_completion'
    });
    
    const success = brainBitesSuccess || screenTimeSuccess;
    console.log(`${success ? '‚úÖ' : '‚ùå'} [HybridTimer] Goal time addition result: ${success}`);
    
    return success;
  } catch (error) {
    console.error('‚ùå [HybridTimer] Error in addTimeFromGoal:', error);
    return false;
  }
}
```

# Fix 2: Update QuizScreen.tsx for Goal Celebration Popup

```typescript
// src/screens/QuizScreen.tsx
// Add these imports at the top
import { NativeEventEmitter, NativeModules } from 'react-native';
import MascotModal from '../components/Mascot/MascotModal';
import DailyGoalsService from '../services/DailyGoalsService';

// Add these state variables in the component
const [showGoalCelebration, setShowGoalCelebration] = useState(false);
const [celebrationGoal, setCelebrationGoal] = useState<{title: string; reward: number} | null>(null);
const [pendingNextQuestion, setPendingNextQuestion] = useState(false);

// Add this useEffect to listen for goal completions
useEffect(() => {
  const eventEmitter = new NativeEventEmitter(NativeModules.DeviceEventEmitter || {});
  
  const goalListener = eventEmitter.addListener('dailyGoalCompleted', (data) => {
    console.log('üéØ [QuizScreen] Daily goal completed event received:', data);
    // Store the goal data for celebration
    setCelebrationGoal({
      title: data.goalTitle,
      reward: data.reward
    });
  });
  
  const honorListener = eventEmitter.addListener('honorGoalCompleted', (data) => {
    console.log('üéØ [QuizScreen] Honor goal completed event received:', data);
    // Store the goal data for celebration
    setCelebrationGoal({
      title: data.goalTitle,
      reward: data.reward
    });
  });
  
  return () => {
    goalListener.remove();
    honorListener.remove();
  };
}, []);

// Update the handleContinue function to check for completed goals
const handleContinue = async () => {
  // Play button sound
  SoundService.playButtonPress();
  
  // Hide mascot if still showing
  setShowMascot(false);
  
  // Check if there's a completed goal to celebrate
  const goals = DailyGoalsService.getGoals();
  const unclaimedCompletedGoal = goals.find(g => g.completed && !g.claimed);
  
  if (unclaimedCompletedGoal || celebrationGoal) {
    // Show celebration instead of moving to next question
    console.log('üéâ [QuizScreen] Showing goal celebration for:', unclaimedCompletedGoal?.title || celebrationGoal?.title);
    
    const goalToShow = unclaimedCompletedGoal || celebrationGoal;
    setCelebrationGoal({
      title: goalToShow.title,
      reward: goalToShow.reward
    });
    setShowGoalCelebration(true);
    setPendingNextQuestion(true); // Mark that we need to load next question after celebration
  } else {
    // No goal to celebrate, proceed normally
    proceedToNextQuestion();
  }
};

// Create a separate function for proceeding to next question
const proceedToNextQuestion = () => {
  // Add a small delay before starting next question
  setTimeout(() => {
    // Hide explanation with animation
    Animated.timing(explanationAnim, {
      toValue: 0,
      duration: 300,
      useNativeDriver: true,
      easing: Easing.in(Easing.cubic),
    }).start(() => {
      // Fix useInsertionEffect error
      setTimeout(() => {
        setShowExplanation(false);
        loadQuestion();
      }, 0);
    });
  }, 100);
};

// Handle claiming the goal reward from celebration
const handleClaimGoalReward = async () => {
  if (!celebrationGoal) return;
  
  try {
    console.log('üéØ [QuizScreen] Claiming goal reward:', celebrationGoal.title);
    
    // Find and claim the goal
    const goals = DailyGoalsService.getGoals();
    const goalToClaim = goals.find(g => g.title === celebrationGoal.title && g.completed && !g.claimed);
    
    if (goalToClaim) {
      const success = await DailyGoalsService.claimReward(goalToClaim.id);
      
      if (success) {
        console.log('‚úÖ [QuizScreen] Goal reward claimed successfully');
        
        // Show success feedback
        const timeInMinutes = Math.floor(goalToClaim.reward / 60);
        Alert.alert(
          '‚è∞ Time Added!',
          `${timeInMinutes} minutes added to your timer!`,
          [{ text: 'Awesome!', style: 'default' }]
        );
      }
    }
    
    // Hide celebration and continue to next question
    setShowGoalCelebration(false);
    setCelebrationGoal(null);
    
    if (pendingNextQuestion) {
      setPendingNextQuestion(false);
      proceedToNextQuestion();
    }
  } catch (error) {
    console.error('‚ùå [QuizScreen] Error claiming goal reward:', error);
    // Still continue even if claim failed
    setShowGoalCelebration(false);
    setCelebrationGoal(null);
    if (pendingNextQuestion) {
      setPendingNextQuestion(false);
      proceedToNextQuestion();
    }
  }
};

// Add the MascotModal for goal celebration at the bottom of the render
return (
  <View style={styles.container}>
    {/* ... existing content ... */}
    
    {/* Goal Celebration Modal - using excited mascot */}
    <MascotModal
      visible={showGoalCelebration}
      type="excited"
      title="üéâ Goal Completed!"
      message={celebrationGoal ? `You completed "${celebrationGoal.title}"!\n\nReward: ${Math.floor(celebrationGoal.reward / 60)} minutes of extra time!` : ''}
      buttons={[
        {
          text: `Claim ${celebrationGoal ? Math.floor(celebrationGoal.reward / 60) : 0} Minutes`,
          onPress: handleClaimGoalReward,
          style: 'primary'
        }
      ]}
      onDismiss={() => {
        // If dismissed without claiming, still continue
        setShowGoalCelebration(false);
        setCelebrationGoal(null);
        if (pendingNextQuestion) {
          setPendingNextQuestion(false);
          proceedToNextQuestion();
        }
      }}
    />
    
    {/* Quit Modal - using depressed mascot */}
    <MascotModal
      visible={showQuitModal}
      type="depressed"
      title="Leaving Already?"
      message={`You're on a ${streak} question streak!\n\nQuitting will reset your progress.`}
      buttons={[
        {
          text: "Let's Continue!",
          onPress: () => {
            SoundService.playButtonPress();
            setShowQuitModal(false);
          },
          style: 'primary'
        },
        {
          text: 'Quit Quiz',
          onPress: async () => {
            SoundService.playButtonPress();
            try {
              await AsyncStorage.setItem('@BrainBites:currentQuizStreak', '0');
            } catch {}
            useQuizStore.getState().resetCurrentStreak();
            setShowQuitModal(false);
            if (navigation.canGoBack()) {
              navigation.goBack();
            } else {
              navigation.navigate('Home');
            }
          },
          style: 'danger'
        }
      ]}
      onDismiss={() => setShowQuitModal(false)}
    />
  </View>
);
```

# Fix 3: Update MascotModal.tsx to Support Top 40% View

```typescript
// src/components/Mascot/MascotModal.tsx
import React, { useEffect, useRef } from 'react';
import {
  Modal,
  View,
  Text,
  StyleSheet,
  TouchableOpacity,
  Animated,
  Dimensions,
  Image,
} from 'react-native';
import LinearGradient from 'react-native-linear-gradient';
import SoundService from '../../services/SoundService';

const { width, height } = Dimensions.get('window');

// Mascot images
const MASCOT_IMAGES = {
  excited: require('../../assets/mascot/excited.png'),
  depressed: require('../../assets/mascot/depressed.png'),
  sad: require('../../assets/mascot/sad.png'),
  happy: require('../../assets/mascot/happy.png'),
};

interface MascotModalProps {
  visible: boolean;
  type?: 'excited' | 'depressed' | 'sad' | 'happy';
  title?: string;
  message: string;
  buttons?: Array<{
    text: string;
    onPress: () => void;
    style: 'primary' | 'secondary' | 'danger';
  }>;
  onDismiss?: () => void;
}

const MascotModal: React.FC<MascotModalProps> = ({
  visible,
  type = 'happy',
  title,
  message,
  buttons = [],
  onDismiss,
}) => {
  const slideAnim = useRef(new Animated.Value(height)).current;
  const fadeAnim = useRef(new Animated.Value(0)).current;
  const scaleAnim = useRef(new Animated.Value(0.8)).current;

  useEffect(() => {
    if (visible) {
      // Play celebration sound for excited mascot
      if (type === 'excited') {
        SoundService.playSuccess();
      }
      
      // Animate modal in
      Animated.parallel([
        Animated.timing(fadeAnim, {
          toValue: 1,
          duration: 300,
          useNativeDriver: true,
        }),
        Animated.spring(slideAnim, {
          toValue: 0,
          tension: 65,
          friction: 10,
          useNativeDriver: true,
        }),
        Animated.spring(scaleAnim, {
          toValue: 1,
          tension: 65,
          friction: 10,
          useNativeDriver: true,
        }),
      ]).start();
    } else {
      // Animate modal out
      Animated.parallel([
        Animated.timing(fadeAnim, {
          toValue: 0,
          duration: 200,
          useNativeDriver: true,
        }),
        Animated.timing(slideAnim, {
          toValue: height,
          duration: 250,
          useNativeDriver: true,
        }),
        Animated.timing(scaleAnim, {
          toValue: 0.8,
          duration: 200,
          useNativeDriver: true,
        }),
      ]).start();
    }
  }, [visible]);

  if (!visible) return null;

  const getButtonStyle = (style: string) => {
    switch (style) {
      case 'primary':
        return styles.primaryButton;
      case 'danger':
        return styles.dangerButton;
      default:
        return styles.secondaryButton;
    }
  };

  return (
    <Modal
      transparent
      visible={visible}
      animationType="none"
      onRequestClose={onDismiss}
    >
      <Animated.View style={[styles.overlay, { opacity: fadeAnim }]}>
        <TouchableOpacity 
          style={StyleSheet.absoluteFillObject} 
          activeOpacity={1}
          onPress={onDismiss}
        />
        
        <Animated.View
          style={[
            styles.modalContainer,
            {
              transform: [
                { translateY: slideAnim },
                { scale: scaleAnim }
              ],
            },
          ]}
        >
          {/* Mascot Image - Top 40% */}
          <View style={styles.mascotContainer}>
            <Image
              source={MASCOT_IMAGES[type]}
              style={styles.mascotImage}
              resizeMode="contain"
            />
            {/* Gradient overlay to fade bottom of mascot */}
            <LinearGradient
              colors={['transparent', 'rgba(26, 31, 46, 0.95)', '#1A1F2E']}
              style={styles.mascotGradient}
            />
          </View>
          
          {/* Content */}
          <View style={styles.content}>
            {title && (
              <Text style={styles.title}>{title}</Text>
            )}
            <Text style={styles.message}>{message}</Text>
            
            {/* Buttons */}
            <View style={styles.buttonContainer}>
              {buttons.map((button, index) => (
                <TouchableOpacity
                  key={index}
                  style={[styles.button, getButtonStyle(button.style)]}
                  onPress={() => {
                    SoundService.playButtonPress();
                    button.onPress();
                  }}
                  activeOpacity={0.8}
                >
                  <Text style={styles.buttonText}>{button.text}</Text>
                </TouchableOpacity>
              ))}
            </View>
          </View>
        </Animated.View>
      </Animated.View>
    </Modal>
  );
};

const styles = StyleSheet.create({
  overlay: {
    flex: 1,
    backgroundColor: 'rgba(0, 0, 0, 0.7)',
    justifyContent: 'center',
    alignItems: 'center',
  },
  modalContainer: {
    width: width * 0.9,
    maxWidth: 400,
    backgroundColor: '#1A1F2E',
    borderRadius: 20,
    overflow: 'hidden',
    elevation: 10,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 10 },
    shadowOpacity: 0.3,
    shadowRadius: 20,
  },
  mascotContainer: {
    height: 200,
    width: '100%',
    position: 'relative',
    overflow: 'hidden',
  },
  mascotImage: {
    width: '100%',
    height: '250%', // Show only top 40% by making image 2.5x larger
    position: 'absolute',
    top: 0,
  },
  mascotGradient: {
    position: 'absolute',
    bottom: 0,
    left: 0,
    right: 0,
    height: 80,
  },
  content: {
    padding: 20,
    paddingTop: 10,
  },
  title: {
    fontSize: 24,
    fontWeight: 'bold',
    color: '#FFFFFF',
    textAlign: 'center',
    marginBottom: 10,
  },
  message: {
    fontSize: 16,
    color: '#B8BED0',
    textAlign: 'center',
    marginBottom: 20,
    lineHeight: 22,
  },
  buttonContainer: {
    flexDirection: 'column',
    gap: 10,
  },
  button: {
    paddingVertical: 14,
    paddingHorizontal: 20,
    borderRadius: 12,
    alignItems: 'center',
  },
  primaryButton: {
    backgroundColor: '#4CAF50',
  },
  secondaryButton: {
    backgroundColor: '#2C3548',
    borderWidth: 1,
    borderColor: '#3A4358',
  },
  dangerButton: {
    backgroundColor: '#FF3B30',
  },
  buttonText: {
    fontSize: 16,
    fontWeight: '600',
    color: '#FFFFFF',
  },
});

export default MascotModal;
```

# Fix 4: Update the handleGoBack function to use MascotModal

```typescript
// In QuizScreen.tsx, update handleGoBack:
const handleGoBack = () => {
  // Show quit modal with depressed mascot
  setShowQuitModal(true);
};
```

## Summary of Changes

1. **Fixed Timer Integration**: Enhanced `HybridTimerService.addTimeFromGoal()` to force refresh both the persistent notification and widget after adding time.

2. **Added Goal Celebration Flow**: 
   - Added state management for goal celebrations
   - Modified `handleContinue()` to check for completed goals
   - Shows MascotModal with excited mascot when goal is completed
   - Breaks the quiz flow and requires claiming reward before continuing

3. **Enhanced MascotModal**: 
   - Added support for showing only top 40% of mascot images
   - Added gradient overlay for smooth transition
   - Properly styled for both celebration and quit scenarios

4. **Quit Flow Update**: 
   - Replaced system alerts with MascotModal using depressed mascot
   - Consistent UI experience throughout the app

These changes ensure that:
- Timer properly updates when goals are claimed
- Users see an exciting celebration when completing goals
- The celebration interrupts the quiz flow as requested
- Visual consistency with mascot appearances (top 40% view)
- All existing functionality remains intact