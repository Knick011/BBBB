# BrainBites App - Complete Fix Solutions

## 1. Enhanced Hourly Milestones with Mascot Personality

### Issue
The hourly milestones feel more like reminders than warnings and need to be more engaging with mascot personality.

### Solution

#### Update `HybridTimerService.ts`

```typescript
// src/services/HybridTimerService.ts

// Update the getHourlyMessages method with more mascot personality
private getHourlyMessages(hours: number, timeString: string): string[] {
  switch (hours) {
    case 1:
      return [
        `😲 Whoa! You just hit your FIRST HOUR of screentime! Maybe it's time for a quick break? 🌿`,
        `🎯 One hour already?! Time flies when you're... staring at screens! Consider a stretch? 🤸`,
        `⏰ HOUR ONE COMPLETE! Your eyes are sending you a message: "We need a break!" 👀`,
        `🚨 Attention! ${timeString} of screentime achieved! Your brain says: "Fresh air sounds nice!" 🌳`
      ];
    case 2:
      return [
        `😰 TWO HOURS! CaBBy is getting worried! Your screen time is at ${timeString}! Break time? 🥺`,
        `🔥 Double hour alert! ${timeString} on screen! Your body is begging for movement! 🏃`,
        `😵 Two hours down! That's ${timeString} of pixels! Time to look at something real? 🌍`,
        `⚠️ WARNING: ${timeString} of screentime! Even I need breaks, and I'm digital! 💭`
      ];
    case 3:
      return [
        `😱 THREE HOURS?! CaBBy is seriously concerned! ${timeString} is A LOT! Please take a break! 🆘`,
        `🚨🚨 CRITICAL: ${timeString} on screen! Your eyes are crying for mercy! 😭`,
        `💀 Three hour milestone! That's ${timeString} of blue light! Nature misses you! 🌲`,
        `🔴 RED ALERT: ${timeString} of screentime! Even robots need maintenance breaks! 🤖`
      ];
    case 4:
      return [
        `😨😨 FOUR HOURS!! CaBBy is PANICKING! ${timeString} is too much! PLEASE REST NOW! 🛑`,
        `🚨🔥 EMERGENCY: ${timeString} on screens! Your health matters more than this! 💚`,
        `☠️ Four hours... ${timeString} of screentime... CaBBy is very disappointed... 😔`,
        `⛔ STOP! ${timeString} is excessive! Time for a REAL break, not a scroll break! 🚶`
      ];
    case 5:
      return [
        `😵‍💫 FIVE HOURS?!? CaBBy is LOSING IT! ${timeString}!! This is an intervention!! 🚑`,
        `🆘🆘🆘 MAYDAY! ${timeString} of screentime! Your future self will thank you for stopping! 🙏`,
        `💔 Five hours... CaBBy's heart is breaking... ${timeString} is harmful! Please stop! 😢`,
        `🔴🔴🔴 CRITICAL OVERLOAD: ${timeString}! Even I'm getting dizzy from all this screen time! 🌀`
      ];
    default: // 6+ hours
      return [
        `😭😭😭 ${hours} HOURS?! CaBBy has given up hope... ${timeString} is digital addiction territory! 📵`,
        `💀💀💀 ${timeString} of screentime... CaBBy is filing a missing person report for your real life! 👮`,
        `🏳️ CaBBy surrenders... ${hours} hours (${timeString}) is beyond intervention... You win, screens... 📱`,
        `⚰️ RIP healthy habits. Cause of death: ${timeString} of screentime. CaBBy will miss you... 🪦`
      ];
  }
}

// Update break suggestions to be more urgent
private getBreakSuggestion(hours: number): string {
  switch(hours) {
    case 1:
      return '\n\n💭 CaBBy suggests: Maybe look out the window for 30 seconds?';
    case 2:
      return '\n\n😟 CaBBy insists: Your eyes REALLY need a 5-minute break! Please?';
    case 3:
      return '\n\n😰 CaBBy begs: PLEASE take a 10-minute walk! Your body needs it!';
    case 4:
      return '\n\n😱 CaBBy demands: STOP NOW! Take at least 15 minutes away from screens!';
    case 5:
      return '\n\n🆘 CaBBy screams: THIS IS NOT HEALTHY! Take a 30-minute break IMMEDIATELY!';
    default:
      return '\n\n💀 CaBBy has fainted from shock. Even virtual mascots have limits...';
  }
}
```

#### Update Android `ScreenTimeService.kt`

```kotlin
// android/app/src/main/java/com/brainbites/timer/ScreenTimeService.kt

private fun showHourlyScreenTimeNotification(hours: Int) {
    try {
        val totalMinutes = todayScreenTimeSeconds / 60
        val displayHours = totalMinutes / 60
        val displayMinutes = totalMinutes % 60
        
        val timeString = if (displayHours > 0) {
            "${displayHours}h ${displayMinutes}m"
        } else {
            "${displayMinutes}m"
        }
        
        val messages = when (hours) {
            1 -> arrayOf(
                "😲 Whoa! You just hit your FIRST HOUR of screentime! Maybe it's time for a quick break? 🌿",
                "🎯 One hour already?! Time flies when you're... staring at screens! Consider a stretch? 🤸",
                "⏰ HOUR ONE COMPLETE! Your eyes are sending you a message: \"We need a break!\" 👀"
            )
            2 -> arrayOf(
                "😰 TWO HOURS! CaBBy is getting worried! Your screen time is at $timeString! Break time? 🥺",
                "🔥 Double hour alert! $timeString on screen! Your body is begging for movement! 🏃",
                "⚠️ WARNING: $timeString of screentime! Even I need breaks, and I'm digital! 💭"
            )
            3 -> arrayOf(
                "😱 THREE HOURS?! CaBBy is seriously concerned! $timeString is A LOT! Please take a break! 🆘",
                "🚨🚨 CRITICAL: $timeString on screen! Your eyes are crying for mercy! 😭",
                "🔴 RED ALERT: $timeString of screentime! Even robots need maintenance breaks! 🤖"
            )
            4 -> arrayOf(
                "😨😨 FOUR HOURS!! CaBBy is PANICKING! $timeString is too much! PLEASE REST NOW! 🛑",
                "🚨🔥 EMERGENCY: $timeString on screens! Your health matters more than this! 💚",
                "⛔ STOP! $timeString is excessive! Time for a REAL break, not a scroll break! 🚶"
            )
            5 -> arrayOf(
                "😵‍💫 FIVE HOURS?!? CaBBy is LOSING IT! $timeString!! This is an intervention!! 🚑",
                "🆘🆘🆘 MAYDAY! $timeString of screentime! Your future self will thank you for stopping! 🙏",
                "🔴🔴🔴 CRITICAL OVERLOAD: $timeString! Even I'm getting dizzy from all this screen time! 🌀"
            )
            else -> arrayOf(
                "😭😭😭 $hours HOURS?! CaBBy has given up hope... $timeString is digital addiction territory! 📵",
                "💀💀💀 $timeString of screentime... CaBBy is filing a missing person report for your real life! 👮",
                "⚰️ RIP healthy habits. Cause of death: $timeString of screentime. CaBBy will miss you... 🪦"
            )
        }
        
        val message = messages.random()
        
        // More urgent break suggestions
        val breakSuggestion = when {
            hours == 1 -> "\n\n💭 CaBBy suggests: Maybe look out the window for 30 seconds?"
            hours == 2 -> "\n\n😟 CaBBy insists: Your eyes REALLY need a 5-minute break! Please?"
            hours == 3 -> "\n\n😰 CaBBy begs: PLEASE take a 10-minute walk! Your body needs it!"
            hours == 4 -> "\n\n😱 CaBBy demands: STOP NOW! Take at least 15 minutes away from screens!"
            hours >= 5 -> "\n\n🆘 CaBBy screams: THIS IS NOT HEALTHY! Take a 30-minute break IMMEDIATELY!"
            else -> "\n\n💀 CaBBy has fainted from shock. Even virtual mascots have limits..."
        }
        
        val notification = NotificationCompat.Builder(this, ALERT_CHANNEL_ID)
            .setSmallIcon(R.drawable.ic_notification)
            .setContentTitle("⚠️ SCREENTIME ALERT from CaBBy!")
            .setContentText(message)
            .setStyle(NotificationCompat.BigTextStyle()
                .bigText(message + breakSuggestion))
            .setPriority(NotificationCompat.PRIORITY_MAX) // Maximum priority for warnings
            .setAutoCancel(true)
            .setDefaults(NotificationCompat.DEFAULT_ALL)
            .setVibrate(longArrayOf(0, 500, 200, 500)) // Double vibration for urgency
            .build()
        
        val notificationId = 5000 + hours
        notificationManagerCompat.notify(notificationId, notification)
    } catch (e: Exception) {
        Log.e(TAG, "Failed to show hourly notification", e)
    }
}
```

## 2. Fix Daily Flow Streak Counter

### Issue
The daily flow element is not properly registering the number of days the streak is going on.

### Solution

#### Update `HomeScreen.tsx`

```typescript
// src/screens/HomeScreen.tsx

const renderStreakFlow = () => {
  const days = ['M', 'T', 'W', 'T', 'F', 'S', 'S'];
  const today = new Date().getDay();
  const mondayFirst = (today + 6) % 7; // Convert to Monday-first
  
  // State for tracking the actual streak count
  const [dailyStreakCount, setDailyStreakCount] = useState(0);
  const [todayCompleted, setTodayCompleted] = useState(false);
  
  useEffect(() => {
    const loadStreakData = async () => {
      try {
        // Load the actual streak count from DailyGoalsService
        const streakData = await AsyncStorage.getItem('@BrainBites:dailyGoalDayStreak');
        const streakCount = streakData ? parseInt(streakData, 10) : 0;
        setDailyStreakCount(streakCount);
        
        // Check if today's goal is completed
        const today = new Date().toISOString().split('T')[0];
        const lastCompleted = await AsyncStorage.getItem('@BrainBites:dailyGoalDayLast');
        setTodayCompleted(lastCompleted === today);
        
        // Update week history based on streak
        const newWeekHistory = [...weekHistory];
        for (let i = 0; i < 7; i++) {
          if (i < mondayFirst) {
            // Past days - check if they were part of the streak
            const daysAgo = mondayFirst - i;
            newWeekHistory[i] = daysAgo <= streakCount;
          } else if (i === mondayFirst) {
            // Today
            newWeekHistory[i] = todayCompleted;
          } else {
            // Future days
            newWeekHistory[i] = false;
          }
        }
        setWeekHistory(newWeekHistory);
      } catch (error) {
        console.error('Error loading streak data:', error);
      }
    };
    
    loadStreakData();
    
    // Listen for daily goal completion events
    const handleGoalCompleted = () => {
      loadStreakData(); // Reload when a goal is completed
    };
    
    DeviceEventEmitter.addListener('dailyGoalDayCompleted', handleGoalCompleted);
    DeviceEventEmitter.addListener('dailyGoalClaimed', handleGoalCompleted);
    
    return () => {
      DeviceEventEmitter.removeListener('dailyGoalDayCompleted', handleGoalCompleted);
      DeviceEventEmitter.removeListener('dailyGoalClaimed', handleGoalCompleted);
    };
  }, [mondayFirst]);
  
  return (
    <LinearGradient
      colors={["#FFF1E0", "#FFE6C6"]}
      start={{ x: 0, y: 0 }}
      end={{ x: 1, y: 1 }}
      style={styles.streakContainer}
    >
      <View style={styles.flowHeader}>
        <View style={styles.flowTitleRow}>
          <Icon name="calendar-check-outline" size={22} color={theme.colors.primary} />
          <Text style={styles.streakTitle}>Daily Flow</Text>
        </View>
        <View style={styles.flowBadge}>
          <Icon name="water" size={14} color="#FFFFFF" />
          <Text style={styles.flowBadgeText}>{dailyStreakCount}d</Text>
        </View>
      </View>
      <Text style={styles.flowSubtitle}>Finish a goal daily to keep your flow alive</Text>
      <View style={styles.weekFlow}>
        {days.map((day, index) => {
          const isToday = index === mondayFirst;
          const dayCompleted = weekHistory[index];
          const isPast = index < mondayFirst;
          const isMissed = isPast && !dayCompleted;
          
          return (
            <View key={index} style={styles.dayItem}>
              <View style={[
                styles.dayCircle,
                isToday && styles.todayCircle,
                dayCompleted && styles.completedCircle,
                isMissed && styles.missedCircle,
              ]}>
                {dayCompleted ? (
                  isToday ? (
                    <Text style={styles.doneText}>✨</Text>
                  ) : (
                    <Icon name="check" size={16} color="#FFFFFF" />
                  )
                ) : isMissed ? (
                  <Icon name="close" size={16} color="#FF6B6B" />
                ) : null}
              </View>
              <Text style={[
                styles.dayLabel,
                isToday && styles.todayLabel,
              ]}>{day}</Text>
              {isToday && todayCompleted && (
                <Text style={styles.todayDoneText}>Done!</Text>
              )}
            </View>
          );
        })}
      </View>
    </LinearGradient>
  );
};
```

## 3. Fix Accuracy Goal NaN Issues

### Issue
Accuracy goal shows NaN/xx and is not being reset at midnight.

### Solution

#### Update `DailyGoalsService.ts`

```typescript
// src/services/DailyGoalsService.ts

async updateProgress(questionData: {
  isCorrect: boolean;
  difficulty: 'easy' | 'medium' | 'hard';
  category?: string;
  currentStreak: number;
  todayAccuracy: number;
  todayQuestions: number;
  responseTimeMs?: number;
}): Promise<void> {
  if (!this.isInitialized) {
    await this.initialize();
  }

  let hasChanges = false;

  for (const goal of this.goals) {
    if (goal.completed || goal.honorBased) continue;

    const oldProgress = goal.progress;

    switch (goal.type) {
      case 'accuracy':
        // Fix NaN issues by ensuring we have valid numbers
        if (questionData.todayQuestions > 0 && goal.questionsRequired) {
          if (questionData.todayQuestions >= goal.questionsRequired) {
            // Calculate accuracy safely
            const accuracy = isNaN(questionData.todayAccuracy) ? 0 : questionData.todayAccuracy;
            goal.current = Math.round(accuracy);
            goal.progress = goal.current >= goal.target ? 100 : (goal.current / goal.target) * 100;
            goal.questionsAnswered = questionData.todayQuestions;
          } else {
            // Not enough questions yet
            goal.current = 0;
            goal.progress = 0;
            goal.questionsAnswered = questionData.todayQuestions;
          }
        } else {
          // No questions answered yet
          goal.current = 0;
          goal.progress = 0;
          goal.questionsAnswered = 0;
        }
        break;
      
      // ... other cases
    }

    // Check if goal is completed
    if (!goal.completed && goal.progress >= 100) {
      goal.completed = true;
      console.log(`🎉 Goal completed: ${goal.title}`);
      
      if (!goal.honorBased && !goal.isSpecial) {
        await this.registerDailyGoalDayCompletion();
      }
    }

    if (goal.progress !== oldProgress) {
      hasChanges = true;
    }
  }

  if (hasChanges) {
    await this.saveGoals();
    this.notifyListeners();
  }
}

// Add midnight reset functionality
async checkAndResetAtMidnight(): Promise<void> {
  const now = new Date();
  const today = this.getTorontoDateString(now);
  
  const lastReset = await AsyncStorage.getItem(this.LAST_RESET_KEY);
  
  if (lastReset !== today) {
    console.log('🌙 Midnight reset triggered');
    
    // Reset all goals including accuracy
    this.goals = await this.generateDailyGoals();
    
    // Reset accuracy tracking in EnhancedScoreService
    const { EnhancedScoreService } = require('./EnhancedScoreService');
    await EnhancedScoreService.resetDailyStats();
    
    await AsyncStorage.setItem(this.LAST_RESET_KEY, today);
    await this.saveGoals();
    this.notifyListeners();
  }
}
```

#### Update `EnhancedScoreService.ts`

```typescript
// src/services/EnhancedScoreService.ts

async resetDailyStats(): Promise<void> {
  this.todayStats = {
    totalQuestions: 0,
    correctAnswers: 0,
    totalScore: 0,
    bestStreak: 0,
    startTime: Date.now()
  };
  
  this.dailyScore = 0;
  this.currentStreak = 0;
  this.highestStreak = 0;
  
  await this.saveAllData();
  console.log('✅ Daily stats reset for new day');
}

getScoreInfo(): ScoreInfo {
  // Fix NaN issues in accuracy calculation
  const accuracy = this.todayStats.totalQuestions > 0 
    ? Math.round((this.todayStats.correctAnswers / this.todayStats.totalQuestions) * 100)
    : 0; // Return 0 instead of NaN when no questions answered
  
  return {
    dailyScore: this.dailyScore,
    totalScore: this.totalScore,
    currentStreak: this.currentStreak,
    highestStreak: this.highestStreak,
    streakLevel: this.streakLevel,
    totalQuestions: this.totalQuestionsAnswered,
    correctAnswers: this.totalCorrectAnswers,
    accuracy: isNaN(accuracy) ? 0 : accuracy, // Additional NaN check
    questionsToday: this.todayStats.totalQuestions,
    bestStreakToday: this.todayStats.bestStreak
  };
}
```

## 4. Fix Morning Notification

### Issue
Morning notification is not being sent at the specified time.

### Solution

#### Create/Update Native Android Module `NotificationModule.kt`

```kotlin
// android/app/src/main/java/com/brainbites/modules/NotificationModule.kt

package com.brainbites.modules

import android.app.AlarmManager
import android.app.PendingIntent
import android.content.Context
import android.content.Intent
import android.os.Build
import com.facebook.react.bridge.*
import java.util.Calendar

class NotificationModule(reactContext: ReactApplicationContext) : ReactContextBaseJavaModule(reactContext) {
    
    override fun getName() = "NotificationModule"
    
    @ReactMethod
    fun scheduleMorningReminder(hour: Int, minute: Int, promise: Promise) {
        try {
            val context = reactApplicationContext
            val alarmManager = context.getSystemService(Context.ALARM_SERVICE) as AlarmManager
            
            // Create intent for the notification
            val intent = Intent(context, MorningNotificationReceiver::class.java).apply {
                putExtra("title", "🌅 Time to Start Your Day Right!")
                putExtra("body", "Let's begin with some brain-boosting questions! Complete a daily goal to keep your streak alive.")
            }
            
            val pendingIntent = PendingIntent.getBroadcast(
                context,
                MORNING_NOTIFICATION_ID,
                intent,
                PendingIntent.FLAG_UPDATE_CURRENT or PendingIntent.FLAG_IMMUTABLE
            )
            
            // Set up the time
            val calendar = Calendar.getInstance().apply {
                timeInMillis = System.currentTimeMillis()
                set(Calendar.HOUR_OF_DAY, hour)
                set(Calendar.MINUTE, minute)
                set(Calendar.SECOND, 0)
                
                // If the time has already passed today, schedule for tomorrow
                if (timeInMillis <= System.currentTimeMillis()) {
                    add(Calendar.DAY_OF_MONTH, 1)
                }
            }
            
            // Cancel any existing alarm
            alarmManager.cancel(pendingIntent)
            
            // Schedule the new alarm
            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.M) {
                alarmManager.setExactAndAllowWhileIdle(
                    AlarmManager.RTC_WAKEUP,
                    calendar.timeInMillis,
                    pendingIntent
                )
            } else {
                alarmManager.setExact(
                    AlarmManager.RTC_WAKEUP,
                    calendar.timeInMillis,
                    pendingIntent
                )
            }
            
            // Schedule repeating daily
            alarmManager.setRepeating(
                AlarmManager.RTC_WAKEUP,
                calendar.timeInMillis,
                AlarmManager.INTERVAL_DAY,
                pendingIntent
            )
            
            promise.resolve(true)
        } catch (e: Exception) {
            promise.reject("SCHEDULE_ERROR", e.message, e)
        }
    }
    
    @ReactMethod
    fun cancelMorningReminder(promise: Promise) {
        try {
            val context = reactApplicationContext
            val alarmManager = context.getSystemService(Context.ALARM_SERVICE) as AlarmManager
            
            val intent = Intent(context, MorningNotificationReceiver::class.java)
            val pendingIntent = PendingIntent.getBroadcast(
                context,
                MORNING_NOTIFICATION_ID,
                intent,
                PendingIntent.FLAG_UPDATE_CURRENT or PendingIntent.FLAG_IMMUTABLE
            )
            
            alarmManager.cancel(pendingIntent)
            promise.resolve(true)
        } catch (e: Exception) {
            promise.reject("CANCEL_ERROR", e.message, e)
        }
    }
    
    companion object {
        private const val MORNING_NOTIFICATION_ID = 9001
    }
}
```

#### Create Broadcast Receiver `MorningNotificationReceiver.kt`

```kotlin
// android/app/src/main/java/com/brainbites/receivers/MorningNotificationReceiver.kt

package com.brainbites.receivers

import android.app.NotificationChannel
import android.app.NotificationManager
import android.app.PendingIntent
import android.content.BroadcastReceiver
import android.content.Context
import android.content.Intent
import android.os.Build
import androidx.core.app.NotificationCompat
import com.brainbites.MainActivity
import com.brainbites.R

class MorningNotificationReceiver : BroadcastReceiver() {
    
    override fun onReceive(context: Context, intent: Intent) {
        val title = intent.getStringExtra("title") ?: "Good Morning!"
        val body = intent.getStringExtra("body") ?: "Time to start your day with BrainBites!"
        
        showNotification(context, title, body)
    }
    
    private fun showNotification(context: Context, title: String, body: String) {
        val notificationManager = context.getSystemService(Context.NOTIFICATION_SERVICE) as NotificationManager
        
        // Create notification channel for Android O and above
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
            val channel = NotificationChannel(
                CHANNEL_ID,
                "Morning Reminders",
                NotificationManager.IMPORTANCE_HIGH
            ).apply {
                description = "Daily morning reminders to complete goals"
                enableVibration(true)
                enableLights(true)
            }
            notificationManager.createNotificationChannel(channel)
        }
        
        // Create intent to open app
        val mainIntent = Intent(context, MainActivity::class.java)
        val pendingIntent = PendingIntent.getActivity(
            context,
            0,
            mainIntent,
            PendingIntent.FLAG_UPDATE_CURRENT or PendingIntent.FLAG_IMMUTABLE
        )
        
        // Build notification
        val notification = NotificationCompat.Builder(context, CHANNEL_ID)
            .setSmallIcon(R.drawable.ic_notification)
            .setContentTitle(title)
            .setContentText(body)
            .setStyle(NotificationCompat.BigTextStyle().bigText(body))
            .setPriority(NotificationCompat.PRIORITY_HIGH)
            .setAutoCancel(true)
            .setDefaults(NotificationCompat.DEFAULT_ALL)
            .setContentIntent(pendingIntent)
            .build()
        
        notificationManager.notify(NOTIFICATION_ID, notification)
    }
    
    companion object {
        private const val CHANNEL_ID = "morning_reminder_channel"
        private const val NOTIFICATION_ID = 9001
    }
}
```

#### Update AndroidManifest.xml

```xml
<!-- Add these permissions and receiver to AndroidManifest.xml -->

<uses-permission android:name="android.permission.SCHEDULE_EXACT_ALARM" />
<uses-permission android:name="android.permission.USE_EXACT_ALARM" />
<uses-permission android:name="android.permission.RECEIVE_BOOT_COMPLETED" />

<!-- Inside <application> tag -->
<receiver 
    android:name=".receivers.MorningNotificationReceiver"
    android:enabled="true"
    android:exported="false" />

<receiver 
    android:name=".receivers.BootReceiver"
    android:enabled="true"
    android:exported="true"
    android:permission="android.permission.RECEIVE_BOOT_COMPLETED">
    <intent-filter>
        <action android:name="android.intent.action.BOOT_COMPLETED" />
    </intent-filter>
</receiver>
```

## 5. Firebase Analytics - Current Events & Recommendations

### Current Events Being Tracked

Based on your `AnalyticsManager.ts`, these events are currently being tracked:

1. **Session Events**
   - `app_open` - When app starts
   - `session_started` - New session begins
   - `session_ended` - Session ends with duration

2. **Quiz Events**
   - `quiz_started` - Category and difficulty
   - `question_answered` - Correct/incorrect, time taken, streak, score earned
   - `quiz_completed` - Total questions, score, accuracy, time

3. **User Progress**
   - `level_up` - New level reached
   - `achievement_unlocked` - Achievement earned
   - `streak_milestone` - Streak milestones (5, 10, 20, etc.)

4. **Daily Goals**
   - `daily_goal_completed` - Goal type, value, reward
   - `goal_claimed` - When reward is claimed

5. **Screen Views**
   - `screen_viewed` - Track screen navigation

6. **Ad Events**
   - `ad_impression` - Ad shown
   - `earn_virtual_currency` - Ad reward earned

### Recommended Additional Analytics

```typescript
// src/services/FirebaseAnalyticsService.ts

// Add these new tracking methods to FirebaseAnalyticsService

class FirebaseAnalyticsService {
  // ... existing code ...

  // CRITICAL USER BEHAVIOR EVENTS
  
  async logUserEngagement(engagementData: {
    sessionLength: number;
    questionsAnswered: number;
    streakMaintained: boolean;
    goalsCompleted: number;
  }): Promise<void> {
    this.analyticsManager.trackEvent('user_engagement', engagementData);
  }

  async logRetention(data: {
    daysSinceInstall: number;
    consecutiveDays: number;
    returningUser: boolean;
  }): Promise<void> {
    this.analyticsManager.trackEvent('retention_check', data);
  }

  async logChurnRisk(data: {
    daysInactive: number;
    lastActivity: string;
    streakLost: boolean;
  }): Promise<void> {
    this.analyticsManager.trackEvent('churn_risk_detected', data);
  }

  // MONETIZATION EVENTS
  
  async logPurchaseIntent(data: {
    itemType: string;
    pricePoint: number;
    abandonedCart: boolean;
  }): Promise<void> {
    this.analyticsManager.trackEvent('purchase_intent', data);
  }

  async logSubscriptionStatus(data: {
    status: 'trial' | 'active' | 'cancelled' | 'expired';
    tier: string;
    daysRemaining: number;
  }): Promise<void> {
    this.analyticsManager.trackEvent('subscription_status', data);
  }

  // FEATURE USAGE
  
  async logFeatureUsage(data: {
    feature: string;
    duration: number;
    completed: boolean;
    firstTime: boolean;
  }): Promise<void> {
    this.analyticsManager.trackEvent('feature_used', data);
  }

  async logTutorialProgress(data: {
    step: number;
    completed: boolean;
    skipped: boolean;
    timeSpent: number;
  }): Promise<void> {
    this.analyticsManager.trackEvent('tutorial_progress', data);
  }

  // PERFORMANCE METRICS
  
  async logAppPerformance(data: {
    loadTime: number;
    crashCount: number;
    memoryUsage: number;
    batteryDrain: number;
  }): Promise<void> {
    this.analyticsManager.trackEvent('app_performance', data);
  }

  async logErrorOccurred(data: {
    errorType: string;
    errorMessage: string;
    screen: string;
    severity: 'low' | 'medium' | 'high' | 'critical';
  }): Promise<void> {
    this.analyticsManager.trackEvent('error_occurred', data);
  }

  // SOCIAL & SHARING
  
  async logSocialShare(data: {
    platform: string;
    contentType: string;
    success: boolean;
  }): Promise<void> {
    this.analyticsManager.trackEvent('social_share', data);
  }

  async logReferral(data: {
    source: string;
    newUser: boolean;
    rewardEarned: boolean;
  }): Promise<void> {
    this.analyticsManager.trackEvent('referral_tracked', data);
  }

  // NOTIFICATION EFFECTIVENESS
  
  async logNotificationInteraction(data: {
    type: string;
    action: 'opened' | 'dismissed' | 'ignored';
    timeSinceSent: number;
  }): Promise<void> {
    this.analyticsManager.trackEvent('notification_interaction', data);
  }

  // CONTENT ENGAGEMENT
  
  async logQuestionQuality(data: {
    questionId: string;
    difficulty: string;
    skipRate: number;
    avgTimeToAnswer: number;
    correctRate: number;
  }): Promise<void> {
    this.analyticsManager.trackEvent('question_quality', data);
  }

  async logCategoryPreference(data: {
    category: string;
    playCount: number;
    avgScore: number;
    preference: 'liked' | 'neutral' | 'disliked';
  }): Promise<void> {
    this.analyticsManager.trackEvent('category_preference', data);
  }

  // A/B TESTING
  
  async logExperimentExposure(data: {
    experimentId: string;
    variant: string;
    userId: string;
  }): Promise<void> {
    this.analyticsManager.trackEvent('experiment_exposure', data);
  }

  async logExperimentConversion(data: {
    experimentId: string;
    variant: string;
    conversionType: string;
    value: number;
  }): Promise<void> {
    this.analyticsManager.trackEvent('experiment_conversion', data);
  }
}
```

### Implementation Example

```typescript
// Example: Track user engagement on app foreground
AppState.addEventListener('change', (nextAppState) => {
  if (nextAppState === 'active') {
    FirebaseAnalyticsService.logUserEngagement({
      sessionLength: getCurrentSessionLength(),
      questionsAnswered: getTodayQuestionCount(),
      streakMaintained: isStreakActive(),
      goalsCompleted: getCompletedGoalsCount()
    });
  }
});

// Example: Track feature usage
const onDailyGoalsOpen = () => {
  const startTime = Date.now();
  
  // When closing/leaving the screen
  FirebaseAnalyticsService.logFeatureUsage({
    feature: 'daily_goals',
    duration: Date.now() - startTime,
    completed: hasClaimedAnyGoal(),
    firstTime: isFirstTimeUser()
  });
};

// Example: Track notification effectiveness
PushNotification.configure({
  onNotification: (notification) => {
    FirebaseAnalyticsService.logNotificationInteraction({
      type: notification.data.type,
      action: 'opened',
      timeSinceSent: Date.now() - notification.sentTime
    });
  }
});
```

## Testing Instructions

1. **Test Hourly Notifications**
   - Use the app for 1 hour continuously
   - Verify increasingly urgent messages appear
   - Check that CaBBy's personality shows through

2. **Test Daily Streak Counter**
   - Complete a daily goal
   - Verify the streak number increments
   - Check that "Done!" appears for today
   - Verify it persists across app restarts

3. **Test Accuracy Goal**
   - Answer questions and check accuracy display
   - Verify no NaN appears
   - Let app run past midnight and verify reset

4. **Test Morning Notification**
   - Set a morning reminder time
   - Close the app
   - Verify notification arrives at set time
   - Test across device restarts

5. **Verify Analytics**
   - Check Firebase Console for events
   - Verify all listed events are being tracked
   - Monitor user engagement metrics

## Important Notes

- The morning notification requires exact alarm permissions on Android 12+
- The streak counter uses the device's local timezone
- Hourly notifications reset at midnight local time
- Analytics require Firebase to be properly configured in your project
- Test on real devices for accurate notification behavior