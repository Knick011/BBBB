// Updated renderStreakFlow function in HomeScreen.tsx
// Replace the existing renderStreakFlow function with this:

const renderStreakFlow = () => {
  const days = ['M', 'T', 'W', 'T', 'F', 'S', 'S'];
  const today = new Date().getDay();
  const mondayFirst = [(today + 6) % 7]; // Convert to Monday-first
  
  // State to track if today is completed
  const [todayCompleted, setTodayCompleted] = useState(false);
  
  // Check if any daily goal has been completed (claimed) today
  useEffect(() => {
    const checkTodayCompletion = async () => {
      try {
        const todayString = new Date().toDateString();
        
        // Check the daily goal day streak data from DailyGoalsService
        const lastCompletedDay = await AsyncStorage.getItem('@BrainBites:lastDailyGoalDay');
        const dayStreak = await AsyncStorage.getItem('@BrainBites:dailyGoalDayStreak');
        
        // Format today as YYYY-MM-DD to match the service format
        const todayFormatted = new Date().toISOString().split('T')[0];
        
        // Check if today has been completed
        const isCompleted = lastCompletedDay === todayFormatted;
        setTodayCompleted(isCompleted);
        
        // Also check claimed rewards for non-honor goals
        const goalsData = await AsyncStorage.getItem('@BrainBites:liveGameStore:claimedRewards');
        const claimedRewards = goalsData ? JSON.parse(goalsData) : {};
        
        // Check if any non-honor goals were claimed today
        const todaysClaims = Object.entries(claimedRewards).filter(([goalId, claimDate]) => {
          if (typeof claimDate === 'string') {
            return new Date(claimDate).toDateString() === todayString;
          }
          return false;
        });
        
        // Filter out honor goals (they don't count for streak)
        const nonHonorClaims = todaysClaims.filter(([goalId]) => 
          !goalId.includes('honor') && !goalId.includes('stretch') && !goalId.includes('read') && !goalId.includes('walk')
        );
        
        if (nonHonorClaims.length > 0 || isCompleted) {
          setTodayCompleted(true);
          console.log('‚úÖ Today marked as completed for daily streak');
        }
      } catch (error) {
        console.error('Error checking today completion:', error);
      }
    };
    
    checkTodayCompletion();
    
    // Re-check when screen gains focus
    const unsubscribe = navigation.addListener('focus', checkTodayCompletion);
    return unsubscribe;
  }, [navigation]);
  
  // Listen for daily goal completion events
  useEffect(() => {
    const eventEmitter = new (require('react-native').NativeEventEmitter)();
    
    const dailyGoalListener = eventEmitter.addListener('dailyGoalDayCompleted', () => {
      console.log('üìÖ Daily goal day completed event received');
      setTodayCompleted(true);
    });
    
    const claimListener = eventEmitter.addListener('dailyGoalClaimed', () => {
      console.log('üéØ Daily goal claimed event received');
      // Re-check completion status
      const checkCompletion = async () => {
        const todayFormatted = new Date().toISOString().split('T')[0];
        const lastCompletedDay = await AsyncStorage.getItem('@BrainBites:lastDailyGoalDay');
        if (lastCompletedDay === todayFormatted) {
          setTodayCompleted(true);
        }
      };
      checkCompletion();
    });
    
    return () => {
      dailyGoalListener.remove();
      claimListener.remove();
    };
  }, []);
  
  return (
    <View style={styles.streakContainer}>
      <Text style={styles.streakTitle}>Daily Goals Streak</Text>
      <View style={styles.weekFlow}>
        {days.map((day, index) => {
          const isToday = index === mondayFirst[0];
          const isPast = index < mondayFirst[0];
          const isCompleted = isPast || (isToday && todayCompleted);
          
          return (
            <View key={index} style={styles.dayItem}>
              <View style={[
                styles.dayCircle,
                isToday && styles.todayCircle,
                isCompleted && styles.completedCircle,
              ]}>
                {isCompleted ? (
                  <Icon name="check" size={16} color="#FFFFFF" />
                ) : (
                  <Text style={[
                    styles.dayText,
                    isToday && styles.todayText,
                  ]}>
                    {day}
                  </Text>
                )}
              </View>
              {isToday && todayCompleted && (
                <Text style={styles.todayCompletedText}>‚ú® Done!</Text>
              )}
            </View>
          );
        })}
      </View>
      {dailyStreak > 0 && (
        <Text style={styles.streakCount}>
          üî• {dailyStreak} day streak!
        </Text>
      )}
    </View>
  );
};

// Add these to the ScreenTimeService.kt file

// In companion object, add:
private const val KEY_LAST_HOUR_NOTIFIED = "last_hour_notified"
private var lastHourNotified = 0

// In onCreate(), add after loadSavedData():
lastHourNotified = sharedPrefs.getInt(KEY_LAST_HOUR_NOTIFIED, 0)

// In updateTimer() function, add this after updating todayScreenTimeSeconds:
private fun updateTimer() {
    try {
        val now = System.currentTimeMillis()
        val deltaMs = now - lastTickTime
        lastTickTime = now
        
        // ... existing midnight detection code ...
        
        // Update timers based on conditions
        val deltaSecs = (deltaMs / 1000.0).toInt()
        if (deltaSecs > 0) {
            val isScreenLocked = keyguardManager.isKeyguardLocked
            val isScreenOn = powerManager.isInteractive
            
            if (isAppInForeground && !isScreenLocked && isScreenOn) {
                // Increment screen time
                todayScreenTimeSeconds += deltaSecs
                sharedPrefs.edit()
                    .putInt(KEY_TODAY_SCREEN_TIME, todayScreenTimeSeconds)
                    .apply()
                
                // Check for hourly milestone
                checkHourlyMilestone()
                
                // Decrement remaining time or increment overtime
                if (remainingTimeSeconds > 0) {
                    remainingTimeSeconds = maxOf(0, remainingTimeSeconds - deltaSecs)
                    sharedPrefs.edit()
                        .putInt(KEY_REMAINING_TIME, remainingTimeSeconds)
                        .apply()
                    
                    // Check warnings
                    when (remainingTimeSeconds) {
                        300 -> showLowTimeNotification(5) // 5 minutes
                        60 -> showLowTimeNotification(1)  // 1 minute
                        0 -> handleTimeExpired()
                    }
                } else if (remainingTimeSeconds <= 0) {
                    // Resume paused overtime if applicable
                    if (overtimePaused && overtimePausedAt > 0) {
                        overtimeSeconds = overtimePausedAt
                        overtimePaused = false
                        overtimePausedAt = 0
                        sharedPrefs.edit()
                            .putBoolean("overtime_paused", false)
                            .remove("overtime_paused_at")
                            .apply()
                        Log.d(TAG, "Resuming overtime at ${overtimeSeconds}s")
                    }
                    
                    // Increment overtime if not paused
                    if (!overtimePaused) {
                        overtimeSeconds++
                        sharedPrefs.edit()
                            .putInt(KEY_OVERTIME, overtimeSeconds)
                            .apply()
                    }
                }
            }
        }
        
        // ... rest of existing code ...
    } catch (e: Exception) {
        Log.e(TAG, "‚ùå Error in updateTimer", e)
    }
}

// Add this new function to check for hourly milestones:
private fun checkHourlyMilestone() {
    val currentHours = todayScreenTimeSeconds / 3600
    
    // Check if we've crossed an hour boundary
    if (currentHours > lastHourNotified) {
        lastHourNotified = currentHours
        sharedPrefs.edit()
            .putInt(KEY_LAST_HOUR_NOTIFIED, lastHourNotified)
            .apply()
        
        // Show hourly notification
        showHourlyScreenTimeNotification(currentHours)
    }
}

// Add this new function to show hourly notifications:
private fun showHourlyScreenTimeNotification(hours: Int) {
    try {
        val totalMinutes = todayScreenTimeSeconds / 60
        val displayHours = totalMinutes / 60
        val displayMinutes = totalMinutes % 60
        
        val timeString = if (displayHours > 0) {
            "${displayHours}h ${displayMinutes}m"
        } else {
            "${displayMinutes}m"
        }
        
        val messages = when (hours) {
            1 -> arrayOf(
                "Whoa! You've spent an hour on your screen today! üì±",
                "One hour milestone reached! Your screentime: $timeString ‚è∞",
                "Hour mark! You've been on screen for $timeString today üïê"
            )
            2 -> arrayOf(
                "Two hours and counting! Screentime: $timeString üìä",
                "Double hour alert! You're at $timeString today ‚è∞‚è∞",
                "2 hour checkpoint! Total today: $timeString üéØ"
            )
            3 -> arrayOf(
                "Three hours reached! Consider a break? Screentime: $timeString üåü",
                "Triple hour milestone! You're at $timeString ‚è∞‚è∞‚è∞",
                "3 hours on screen! Maybe time for a stretch? Total: $timeString ü§∏"
            )
            4 -> arrayOf(
                "Four hours of screentime! You're at $timeString üìà",
                "Quad hour alert! Total screentime: $timeString ‚è∞‚è∞‚è∞‚è∞",
                "4 hour mark reached! Consider some offline time? Total: $timeString üå≥"
            )
            else -> arrayOf(
                "Screentime milestone: $hours hours! Total today: $timeString üìä",
                "$hours hour alert! You've spent $timeString on screen ‚è∞",
                "Hour $hours reached! Your screentime is now $timeString üì±"
            )
        }
        
        val message = messages.random()
        
        // Add emoji suggestions for breaks
        val breakSuggestion = when {
            hours >= 3 -> "\n\nüí° Tip: How about a quick walk or stretch?"
            hours >= 2 -> "\n\nüëÄ Remember to rest your eyes!"
            else -> ""
        }
        
        val notification = NotificationCompat.Builder(this, ALERT_CHANNEL_ID)
            .setSmallIcon(R.drawable.ic_notification)
            .setContentTitle("üì± Screentime Milestone!")
            .setContentText(message)
            .setStyle(NotificationCompat.BigTextStyle()
                .bigText(message + breakSuggestion))
            .setPriority(NotificationCompat.PRIORITY_HIGH)
            .setAutoCancel(true)
            .setDefaults(NotificationCompat.DEFAULT_ALL)
            .setContentIntent(pendingIntent)
            .build()
        
        // Use unique ID for each hour
        val notificationId = 5000 + hours
        notificationManagerCompat.notify(notificationId, notification)
        
        Log.d(TAG, "üì± Hourly screentime notification shown for hour $hours")
    } catch (e: Exception) {
        Log.e(TAG, "‚ùå Failed to show hourly notification", e)
    }
}

// In loadSavedData(), add:
private fun loadSavedData() {
    val today = android.text.format.DateFormat.format("yyyy-MM-dd", java.util.Date()).toString()
    val lastSaveDate = sharedPrefs.getString(KEY_LAST_SAVE_DATE, today)
    
    if (lastSaveDate != today) {
        // Reset daily data
        todayScreenTimeSeconds = 0
        overtimeSeconds = 0
        overtimePaused = false
        overtimePausedAt = 0
        lastHourNotified = 0  // Reset hourly notification counter
        sharedPrefs.edit()
            .putInt(KEY_TODAY_SCREEN_TIME, 0)
            .putInt(KEY_OVERTIME, 0)
            .putBoolean("overtime_paused", false)
            .remove("overtime_paused_at")
            .putInt(KEY_LAST_HOUR_NOTIFIED, 0)
            .putString(KEY_LAST_SAVE_DATE, today)
            .apply()
        Log.d(TAG, "üìÖ New day detected - daily counters reset")
    } else {
        remainingTimeSeconds = sharedPrefs.getInt(KEY_REMAINING_TIME, 0)
        todayScreenTimeSeconds = sharedPrefs.getInt(KEY_TODAY_SCREEN_TIME, 0)
        overtimeSeconds = sharedPrefs.getInt(KEY_OVERTIME, 0)
        overtimePaused = sharedPrefs.getBoolean("overtime_paused", false)
        overtimePausedAt = sharedPrefs.getInt("overtime_paused_at", 0)
        lastHourNotified = sharedPrefs.getInt(KEY_LAST_HOUR_NOTIFIED, 0)
    }
    
    Log.d(TAG, "üìä Loaded data - Remaining: ${remainingTimeSeconds}s, Today: ${todayScreenTimeSeconds}s, Overtime: ${overtimeSeconds}s, LastHour: $lastHourNotified")
}

// Add these to HybridTimerService.ts

import { NotificationService } from './NotificationService';

class HybridTimerService {
  // ... existing properties ...
  
  private lastHourNotified: number = 0;
  private readonly HOURLY_NOTIFICATION_KEY = '@BrainBites:lastHourNotified';
  
  // ... existing code ...
  
  /**
   * Initialize the timer service
   */
  async initialize(): Promise<void> {
    console.log('üîÑ [HybridTimer] Initializing hybrid timer service');
    
    // Load saved timer state
    await this.loadTimerState();
    
    // Load last hour notified
    const savedHour = await AsyncStorage.getItem(this.HOURLY_NOTIFICATION_KEY);
    this.lastHourNotified = savedHour ? parseInt(savedHour, 10) : 0;
    
    // Check if we need to reset for new day
    const today = new Date().toDateString();
    const lastReset = await AsyncStorage.getItem('@BrainBites:lastTimerReset');
    if (lastReset !== today) {
      this.lastHourNotified = 0;
      await AsyncStorage.setItem(this.HOURLY_NOTIFICATION_KEY, '0');
      await AsyncStorage.setItem('@BrainBites:lastTimerReset', today);
    }
    
    // ... rest of existing initialization ...
  }
  
  /**
   * Handle timer update from native service
   */
  private async handleTimerUpdate(data: TimerData): Promise<void> {
    console.log('‚è±Ô∏è [HybridTimer] Timer update received:', {
      timeLeft: data.remainingTime,
      screenTime: data.todayScreenTime,
      overtime: data.overtime,
      tracking: data.isTracking
    });
    
    // Store previous values for comparison
    const previousScreenTime = this.screenTime;
    
    // Update local state
    this.timeLeft = data.remainingTime;
    this.screenTime = data.todayScreenTime;
    this.overtime = data.overtime;
    this.overtimePaused = false; // Will be updated if needed
    
    // Check for hourly milestone
    await this.checkHourlyMilestone();
    
    // Update current data and notify listeners
    this.updateCurrentData();
    
    // Save state periodically (every 30 seconds)
    if (this.screenTime % 30 === 0 && this.screenTime !== previousScreenTime) {
      await this.saveTimerState();
    }
  }
  
  /**
   * Check if we've reached an hourly milestone
   */
  private async checkHourlyMilestone(): Promise<void> {
    const currentHours = Math.floor(this.screenTime / 3600);
    
    // Check if we've crossed an hour boundary
    if (currentHours > this.lastHourNotified && currentHours > 0) {
      this.lastHourNotified = currentHours;
      await AsyncStorage.setItem(this.HOURLY_NOTIFICATION_KEY, currentHours.toString());
      
      // Show hourly notification
      await this.showHourlyNotification(currentHours);
    }
  }
  
  /**
   * Show hourly screentime notification
   */
  private async showHourlyNotification(hours: number): Promise<void> {
    try {
      const totalMinutes = Math.floor(this.screenTime / 60);
      const displayHours = Math.floor(totalMinutes / 60);
      const displayMinutes = totalMinutes % 60;
      
      const timeString = displayHours > 0 
        ? `${displayHours}h ${displayMinutes}m`
        : `${displayMinutes}m`;
      
      // Create varied messages based on hour
      const messages = this.getHourlyMessages(hours, timeString);
      const message = messages[Math.floor(Math.random() * messages.length)];
      
      // Add break suggestions for longer sessions
      const breakSuggestion = this.getBreakSuggestion(hours);
      
      // Use NotificationService to show the notification
      await NotificationService.showLocalNotification({
        title: 'üì± Screentime Milestone!',
        body: message + breakSuggestion,
        data: { 
          type: 'hourly_screentime',
          hours: hours,
          totalTime: this.screenTime
        }
      });
      
      console.log(`üì± [HybridTimer] Hourly notification shown for hour ${hours}`);
      
      // Also emit event for UI updates
      const eventEmitter = new (require('react-native').NativeEventEmitter)();
      eventEmitter.emit('hourlyScreentime', {
        hours,
        totalSeconds: this.screenTime,
        timeString
      });
      
    } catch (error) {
      console.error('‚ùå [HybridTimer] Failed to show hourly notification:', error);
    }
  }
  
  /**
   * Get varied messages for hourly notifications
   */
  private getHourlyMessages(hours: number, timeString: string): string[] {
    switch (hours) {
      case 1:
        return [
          `Whoa! You've spent an hour on your screen today! üì±`,
          `One hour milestone reached! Your screentime: ${timeString} ‚è∞`,
          `Hour mark! You've been on screen for ${timeString} today üïê`,
          `First hour complete! Total screentime: ${timeString} üìä`
        ];
      case 2:
        return [
          `Two hours and counting! Screentime: ${timeString} üìä`,
          `Double hour alert! You're at ${timeString} today ‚è∞‚è∞`,
          `2 hour checkpoint! Total today: ${timeString} üéØ`,
          `Two hours on screen! Current total: ${timeString} üì±`
        ];
      case 3:
        return [
          `Three hours reached! Consider a break? Screentime: ${timeString} üåü`,
          `Triple hour milestone! You're at ${timeString} ‚è∞‚è∞‚è∞`,
          `3 hours on screen! Maybe time for a stretch? Total: ${timeString} ü§∏`,
          `Third hour complete! Your screentime: ${timeString} üìà`
        ];
      case 4:
        return [
          `Four hours of screentime! You're at ${timeString} üìà`,
          `Quad hour alert! Total screentime: ${timeString} ‚è∞‚è∞‚è∞‚è∞`,
          `4 hour mark reached! Consider some offline time? Total: ${timeString} üå≥`,
          `Four hours logged! Current total: ${timeString} üì±`
        ];
      case 5:
        return [
          `Five hours on screen! You're at ${timeString} üìä`,
          `5 hour milestone! Total today: ${timeString} ‚è∞`,
          `Fifth hour reached! Maybe time for a longer break? Total: ${timeString} üåø`,
          `Five hours of screentime logged: ${timeString} üì±`
        ];
      default:
        return [
          `Screentime milestone: ${hours} hours! Total today: ${timeString} üìä`,
          `${hours} hour alert! You've spent ${timeString} on screen ‚è∞`,
          `Hour ${hours} reached! Your screentime is now ${timeString} üì±`,
          `${hours} hours logged! Current total: ${timeString} üìà`
        ];
    }
  }
  
  /**
   * Get break suggestion based on hours
   */
  private getBreakSuggestion(hours: number): string {
    if (hours >= 5) {
      return '\n\nüö∂ Suggestion: Time for a proper break! How about a 15-minute walk?';
    } else if (hours >= 4) {
      return '\n\nüå≥ Tip: Consider some offline time to recharge!';
    } else if (hours >= 3) {
      return '\n\nüí° Tip: How about a quick walk or stretch?';
    } else if (hours >= 2) {
      return '\n\nüëÄ Remember to rest your eyes!';
    }
    return '';
  }
  
  /**
   * Get current timer state
   */
  getCurrentState(): TimerState {
    const hoursSpent = Math.floor(this.screenTime / 3600);
    const minutesSpent = Math.floor((this.screenTime % 3600) / 60);
    
    return {
      timeLeft: this.timeLeft,
      screenTime: this.screenTime,
      overtime: this.overtime,
      overtimePaused: this.overtimePaused,
      isTracking: this.currentData?.isTracking || false,
      isAppForeground: this.currentData?.isAppForeground || false,
      lastUpdate: Date.now(),
      todayHours: hoursSpent,
      todayMinutes: minutesSpent,
      lastHourNotified: this.lastHourNotified
    };
  }
  
  // ... rest of existing code ...
}

// Add these methods to NotificationService.ts

interface LocalNotificationData {
  title: string;
  body: string;
  data?: any;
  playSound?: boolean;
  vibrate?: boolean;
}

class NotificationServiceClass {
  // ... existing code ...
  
  /**
   * Show a local notification immediately
   */
  async showLocalNotification(notification: LocalNotificationData): Promise<void> {
    try {
      if (!this.isInitialized || !this.settings.enabled) {
        console.log('‚ö†Ô∏è Notifications not enabled, skipping');
        return;
      }
      
      const { NativeModules, Platform } = require('react-native');
      
      if (Platform.OS === 'android') {
        const { NotificationModule } = NativeModules;
        
        if (NotificationModule && NotificationModule.showNotification) {
          await NotificationModule.showNotification({
            title: notification.title,
            message: notification.body,
            playSound: notification.playSound !== false,
            vibrate: notification.vibrate !== false,
            data: notification.data || {}
          });
          
          console.log('‚úÖ Local notification shown:', notification.title);
        }
      } else if (Platform.OS === 'ios') {
        // iOS implementation using PushNotificationIOS
        const PushNotificationIOS = require('@react-native-community/push-notification-ios').default;
        
        PushNotificationIOS.addNotificationRequest({
          id: `local_${Date.now()}`,
          title: notification.title,
          body: notification.body,
          sound: notification.playSound !== false ? 'default' : undefined,
          userInfo: notification.data || {}
        });
        
        console.log('‚úÖ iOS local notification shown:', notification.title);
      }
    } catch (error) {
      console.error('‚ùå Failed to show local notification:', error);
    }
  }
  
  /**
   * Schedule hourly screentime reminders
   */
  async scheduleHourlyReminders(enabled: boolean = true): Promise<void> {
    try {
      const key = '@BrainBites:hourlyRemindersEnabled';
      
      if (enabled) {
        await AsyncStorage.setItem(key, 'true');
        console.log('‚úÖ Hourly screentime reminders enabled');
      } else {
        await AsyncStorage.setItem(key, 'false');
        console.log('‚è∏Ô∏è Hourly screentime reminders disabled');
      }
      
      // Update settings
      this.settings = {
        ...this.settings,
        hourlyReminders: enabled
      };
      await this.saveSettings();
      
    } catch (error) {
      console.error('‚ùå Failed to update hourly reminder settings:', error);
    }
  }
  
  /**
   * Check if hourly reminders are enabled
   */
  async areHourlyRemindersEnabled(): Promise<boolean> {
    try {
      const enabled = await AsyncStorage.getItem('@BrainBites:hourlyRemindersEnabled');
      return enabled !== 'false'; // Default to true
    } catch (error) {
      console.error('Error checking hourly reminder status:', error);
      return true; // Default to enabled
    }
  }
  
  /**
   * Show a motivational notification for break time
   */
  async showBreakNotification(hours: number): Promise<void> {
    const breakMessages = [
      'üßò Time for a mindful break! Your eyes will thank you.',
      'üö∂ How about a quick walk? Movement boosts brain power!',
      'üíß Hydration check! When did you last have some water?',
      'üåü Great job tracking your time! Now for a quick refresh.',
      'üéØ You\'re doing great! A short break will help you focus better.'
    ];
    
    const message = breakMessages[Math.floor(Math.random() * breakMessages.length)];
    
    await this.showLocalNotification({
      title: '‚è∞ Break Time Suggestion',
      body: message,
      data: { type: 'break_reminder', hours }
    });
  }
  
  /**
   * Clear specific notification by ID (for Android)
   */
  async clearNotification(notificationId: number): Promise<void> {
    try {
      const { NativeModules, Platform } = require('react-native');
      
      if (Platform.OS === 'android') {
        const { NotificationModule } = NativeModules;
        if (NotificationModule && NotificationModule.clearNotification) {
          await NotificationModule.clearNotification(notificationId);
        }
      }
    } catch (error) {
      console.error('Failed to clear notification:', error);
    }
  }
  
  // ... existing code ...
}

// Create this file at: android/app/src/main/java/com/brainbites/modules/NotificationModule.kt

package com.brainbites.modules

import android.app.NotificationChannel
import android.app.NotificationManager
import android.app.PendingIntent
import android.content.Context
import android.content.Intent
import android.os.Build
import androidx.core.app.NotificationCompat
import com.facebook.react.bridge.*
import com.brainbites.MainActivity
import com.brainbites.R
import org.json.JSONObject

class NotificationModule(reactContext: ReactApplicationContext) : ReactContextBaseJavaModule(reactContext) {
    
    companion object {
        private const val CHANNEL_ID = "brainbites_general"
        private const val CHANNEL_NAME = "BrainBites Notifications"
        private const val CHANNEL_DESC = "General notifications from BrainBites"
    }
    
    override fun getName(): String = "NotificationModule"
    
    init {
        createNotificationChannel()
    }
    
    private fun createNotificationChannel() {
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
            val importance = NotificationManager.IMPORTANCE_HIGH
            val channel = NotificationChannel(CHANNEL_ID, CHANNEL_NAME, importance).apply {
                description = CHANNEL_DESC
                enableVibration(true)
                enableLights(true)
            }
            
            val notificationManager = reactApplicationContext.getSystemService(Context.NOTIFICATION_SERVICE) as NotificationManager
            notificationManager.createNotificationChannel(channel)
        }
    }
    
    @ReactMethod
    fun showNotification(params: ReadableMap, promise: Promise) {
        try {
            val title = params.getString("title") ?: "BrainBites"
            val message = params.getString("message") ?: ""
            val playSound = if (params.hasKey("playSound")) params.getBoolean("playSound") else true
            val vibrate = if (params.hasKey("vibrate")) params.getBoolean("vibrate") else true
            val data = if (params.hasKey("data")) params.getMap("data") else null
            
            // Create intent for notification tap
            val intent = Intent(reactApplicationContext, MainActivity::class.java).apply {
                flags = Intent.FLAG_ACTIVITY_NEW_TASK or Intent.FLAG_ACTIVITY_CLEAR_TOP
                
                // Add data to intent
                data?.let { map ->
                    val iterator = map.keySetIterator()
                    while (iterator.hasNextKey()) {
                        val key = iterator.nextKey()
                        when (val value = map.getDynamic(key)) {
                            is ReadableType -> {
                                when (value.type) {
                                    ReadableType.String -> putExtra(key, map.getString(key))
                                    ReadableType.Number -> putExtra(key, map.getDouble(key))
                                    ReadableType.Boolean -> putExtra(key, map.getBoolean(key))
                                    else -> {}
                                }
                            }
                        }
                    }
                }
            }
            
            val pendingIntent = PendingIntent.getActivity(
                reactApplicationContext,
                System.currentTimeMillis().toInt(),
                intent,
                PendingIntent.FLAG_UPDATE_CURRENT or PendingIntent.FLAG_IMMUTABLE
            )
            
            // Build notification
            val notificationBuilder = NotificationCompat.Builder(reactApplicationContext, CHANNEL_ID)
                .setSmallIcon(R.drawable.ic_notification)
                .setContentTitle(title)
                .setContentText(message)
                .setStyle(NotificationCompat.BigTextStyle().bigText(message))
                .setPriority(NotificationCompat.PRIORITY_HIGH)
                .setAutoCancel(true)
                .setContentIntent(pendingIntent)
            
            // Set sound and vibration
            if (playSound || vibrate) {
                var defaults = 0
                if (playSound) defaults = defaults or NotificationCompat.DEFAULT_SOUND
                if (vibrate) defaults = defaults or NotificationCompat.DEFAULT_VIBRATE
                notificationBuilder.setDefaults(defaults)
            }
            
            // Show notification
            val notificationManager = reactApplicationContext.getSystemService(Context.NOTIFICATION_SERVICE) as NotificationManager
            val notificationId = System.currentTimeMillis().toInt()
            notificationManager.notify(notificationId, notificationBuilder.build())
            
            promise.resolve(notificationId)
        } catch (e: Exception) {
            promise.reject("NOTIFICATION_ERROR", "Failed to show notification: ${e.message}", e)
        }
    }
    
    @ReactMethod
    fun clearNotification(notificationId: Int, promise: Promise) {
        try {
            val notificationManager = reactApplicationContext.getSystemService(Context.NOTIFICATION_SERVICE) as NotificationManager
            notificationManager.cancel(notificationId)
            promise.resolve(true)
        } catch (e: Exception) {
            promise.reject("CLEAR_ERROR", "Failed to clear notification: ${e.message}", e)
        }
    }
    
    @ReactMethod
    fun clearAllNotifications(promise: Promise) {
        try {
            val notificationManager = reactApplicationContext.getSystemService(Context.NOTIFICATION_SERVICE) as NotificationManager
            notificationManager.cancelAll()
            promise.resolve(true)
        } catch (e: Exception) {
            promise.reject("CLEAR_ALL_ERROR", "Failed to clear all notifications: ${e.message}", e)
        }
    }
}

// Add this to your MainApplication.kt or create a new ReactPackage

// In MainApplication.kt, add this ReactPackage:

package com.brainbites

import com.facebook.react.ReactPackage
import com.facebook.react.bridge.NativeModule
import com.facebook.react.bridge.ReactApplicationContext
import com.facebook.react.uimanager.ViewManager
import com.brainbites.modules.NotificationModule

class BrainBitesPackage : ReactPackage {
    override fun createNativeModules(reactContext: ReactApplicationContext): List<NativeModule> {
        return listOf(
            NotificationModule(reactContext)
            // Add other native modules here
        )
    }
    
    override fun createViewManagers(reactContext: ReactApplicationContext): List<ViewManager<*, *>> {
        return emptyList()
    }
}

// Then in MainApplication's getPackages() method, add:
override protected fun getPackages(): List<ReactPackage> {
    return PackageList(this).packages.apply {
        // Add your custom package
        add(BrainBitesPackage())
    }
}// Add this to your MainApplication.kt or create a new ReactPackage

// In MainApplication.kt, add this ReactPackage:

package com.brainbites

import com.facebook.react.ReactPackage
import com.facebook.react.bridge.NativeModule
import com.facebook.react.bridge.ReactApplicationContext
import com.facebook.react.uimanager.ViewManager
import com.brainbites.modules.NotificationModule

class BrainBitesPackage : ReactPackage {
    override fun createNativeModules(reactContext: ReactApplicationContext): List<NativeModule> {
        return listOf(
            NotificationModule(reactContext)
            // Add other native modules here
        )
    }
    
    override fun createViewManagers(reactContext: ReactApplicationContext): List<ViewManager<*, *>> {
        return emptyList()
    }
}

// Then in MainApplication's getPackages() method, add:
override protected fun getPackages(): List<ReactPackage> {
    return PackageList(this).packages.apply {
        // Add your custom package
        add(BrainBitesPackage())
    }
}

# Implementation Summary: Daily Streak Fix & Hourly Screentime Notifications

## 1. Daily Streak Fix

### Problem
The daily streak element in the home screen wasn't properly registering when daily goals were completed and claimed.

### Solution
Updated the `renderStreakFlow` function in `HomeScreen.tsx` to:
- Properly check AsyncStorage for the daily goal completion status
- Listen to `dailyGoalDayCompleted` and `dailyGoalClaimed` events
- Compare dates in the correct format (YYYY-MM-DD)
- Update the UI immediately when a goal is completed
- Show "‚ú® Done!" text when today's goal is achieved

### Key Changes:
- Added state tracking for `todayCompleted`
- Added event listeners for daily goal events
- Fixed date comparison logic
- Added visual feedback for completed days

## 2. Hourly Screentime Notifications

### Android Implementation (ScreenTimeService.kt)

Added the following features:
- **Hour tracking**: Tracks the last hour for which a notification was sent
- **Hourly check**: `checkHourlyMilestone()` function that triggers when crossing hour boundaries
- **Varied messages**: Different notification messages for each hour (1-5+ hours)
- **Break suggestions**: Helpful tips based on screentime duration
- **Persistence**: Saves `lastHourNotified` to SharedPreferences

### TypeScript Implementation (HybridTimerService.ts)

Added:
- **Hour milestone detection**: Checks when screentime crosses hour boundaries
- **Notification dispatch**: Uses NotificationService to show local notifications
- **Message variety**: Array of different messages for each hour
- **Break suggestions**: Progressive suggestions based on hours spent
- **Event emission**: Emits `hourlyScreentime` events for UI updates

### NotificationService Enhancement

Added new methods:
- `showLocalNotification()`: Shows immediate local notifications
- `scheduleHourlyReminders()`: Enable/disable hourly reminders
- `areHourlyRemindersEnabled()`: Check reminder status
- `showBreakNotification()`: Special break time notifications
- `clearNotification()`: Clear specific notifications

### Native Android Module (NotificationModule.kt)

Created a new native module for better notification control:
- Proper notification channel setup
- Support for custom data in notifications
- Sound and vibration control
- Notification clearing capabilities

## 3. Installation Steps

1. **Update HomeScreen.tsx**: Replace the `renderStreakFlow` function with the updated version
2. **Update ScreenTimeService.kt**: Add the hourly notification logic
3. **Update HybridTimerService.ts**: Add hourly milestone checking
4. **Update NotificationService.ts**: Add new notification methods
5. **Create NotificationModule.kt**: Add the native Android module
6. **Register the module**: Update MainApplication.kt to register the new module

## 4. Features Added

### Daily Streak
- ‚úÖ Properly detects when daily goals are completed
- ‚úÖ Shows "Done!" indicator for today when goal is achieved
- ‚úÖ Updates immediately upon goal claim
- ‚úÖ Distinguishes between regular and honor goals (honor goals don't count for streak)

### Hourly Notifications
- ‚úÖ Sends notification every hour of screentime
- ‚úÖ Varied messages to keep it interesting
- ‚úÖ Progressive break suggestions (eyes rest at 2h, walk at 3h, etc.)
- ‚úÖ Tracks across app restarts
- ‚úÖ Resets daily at midnight
- ‚úÖ Shows total screentime in notification (e.g., "2h 34m")

## 5. Testing Checklist

- [ ] Complete a daily goal and verify streak updates
- [ ] Check that honor goals don't trigger streak updates
- [ ] Verify "Done!" appears on today's circle when goal completed
- [ ] Use app for 1 hour and verify notification appears
- [ ] Check that hourly notifications show correct time
- [ ] Verify notifications have varied messages
- [ ] Test that notifications reset at midnight
- [ ] Confirm break suggestions appear at appropriate times

## 6. Configuration

The hourly notifications are enabled by default but can be toggled:
```typescript
// Enable hourly notifications
await NotificationService.scheduleHourlyReminders(true);

// Disable hourly notifications
await NotificationService.scheduleHourlyReminders(false);
```

## 7. Important Notes

- The daily streak only counts **regular** daily goals (not honor-based goals)
- Hourly notifications will only trigger while the app is actively tracking screentime
- Notifications reset at midnight based on device local time
- All notification texts are family-friendly and encouraging
- Break suggestions become more prominent as screentime increases