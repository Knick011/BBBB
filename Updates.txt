Here are the comprehensive updates to fix all 5 issues:
1. COMPREHENSIVE DAILY GOALS WITH MASCOTMODAL
Create/Update src/components/Mascot/MascotModal.tsx:

// src/components/Mascot/MascotModal.tsx
import React, { useEffect, useRef, useState } from 'react';
import {
  Modal,
  View,
  Text,
  StyleSheet,
  TouchableOpacity,
  Animated,
  Dimensions,
  Platform,
} from 'react-native';
import Icon from 'react-native-vector-icons/MaterialCommunityIcons';
import LinearGradient from 'react-native-linear-gradient';
import SoundService from '../../services/SoundService';

const { width, height } = Dimensions.get('window');

interface MascotModalProps {
  visible: boolean;
  type?: 'excited' | 'sad' | 'warning' | 'celebration';
  title?: string;
  message: string;
  reward?: number;
  onDismiss: () => void;
  buttons?: Array<{
    text: string;
    onPress: () => void;
    style: 'primary' | 'secondary' | 'danger';
  }>;
  autoHide?: boolean;
  autoHideDelay?: number;
}

const MascotModal: React.FC<MascotModalProps> = ({
  visible,
  type = 'excited',
  title,
  message,
  reward,
  onDismiss,
  buttons,
  autoHide = false,
  autoHideDelay = 5000,
}) => {
  const [showModal, setShowModal] = useState(false);
  const scaleAnim = useRef(new Animated.Value(0)).current;
  const bounceAnim = useRef(new Animated.Value(0)).current;
  const fadeAnim = useRef(new Animated.Value(0)).current;
  const particleAnims = useRef(
    Array(6).fill(null).map(() => ({
      x: new Animated.Value(0),
      y: new Animated.Value(0),
      opacity: new Animated.Value(0),
      scale: new Animated.Value(0),
    }))
  ).current;
  
  const hideTimer = useRef<NodeJS.Timeout | null>(null);

  useEffect(() => {
    if (visible) {
      setShowModal(true);
      animateIn();
      
      if (autoHide) {
        hideTimer.current = setTimeout(() => {
          onDismiss();
        }, autoHideDelay);
      }
    } else {
      animateOut();
    }
    
    return () => {
      if (hideTimer.current) {
        clearTimeout(hideTimer.current);
      }
    };
  }, [visible]);

  const animateIn = () => {
    // Play sound based on type
    if (type === 'excited' || type === 'celebration') {
      SoundService.playStreak();
    }
    
    // Animate modal
    Animated.sequence([
      Animated.parallel([
        Animated.spring(scaleAnim, {
          toValue: 1,
          friction: 4,
          tension: 40,
          useNativeDriver: true,
        }),
        Animated.timing(fadeAnim, {
          toValue: 1,
          duration: 300,
          useNativeDriver: true,
        }),
      ]),
      Animated.loop(
        Animated.sequence([
          Animated.timing(bounceAnim, {
            toValue: -10,
            duration: 1000,
            useNativeDriver: true,
          }),
          Animated.timing(bounceAnim, {
            toValue: 0,
            duration: 1000,
            useNativeDriver: true,
          }),
        ])
      ),
    ]).start();
    
    // Animate particles for celebration
    if (type === 'celebration' || (type === 'excited' && reward)) {
      animateParticles();
    }
  };

  const animateOut = () => {
    Animated.parallel([
      Animated.timing(scaleAnim, {
        toValue: 0,
        duration: 300,
        useNativeDriver: true,
      }),
      Animated.timing(fadeAnim, {
        toValue: 0,
        duration: 300,
        useNativeDriver: true,
      }),
    ]).start(() => {
      setShowModal(false);
    });
  };

  const animateParticles = () => {
    particleAnims.forEach((anim, index) => {
      const delay = index * 100;
      const angle = (index * 60) * Math.PI / 180;
      const distance = 100 + Math.random() * 50;
      
      Animated.sequence([
        Animated.delay(delay),
        Animated.parallel([
          Animated.timing(anim.opacity, {
            toValue: 1,
            duration: 200,
            useNativeDriver: true,
          }),
          Animated.spring(anim.scale, {
            toValue: 1,
            friction: 5,
            useNativeDriver: true,
          }),
          Animated.timing(anim.x, {
            toValue: Math.cos(angle) * distance,
            duration: 1000,
            useNativeDriver: true,
          }),
          Animated.timing(anim.y, {
            toValue: Math.sin(angle) * distance,
            duration: 1000,
            useNativeDriver: true,
          }),
        ]),
        Animated.timing(anim.opacity, {
          toValue: 0,
          duration: 500,
          useNativeDriver: true,
        }),
      ]).start();
    });
  };

  const getMascotEmoji = () => {
    switch (type) {
      case 'excited':
      case 'celebration':
        return 'üéâ';
      case 'sad':
        return 'üò¢';
      case 'warning':
        return '‚ö†Ô∏è';
      default:
        return 'üòä';
    }
  };

  const getGradientColors = () => {
    switch (type) {
      case 'excited':
      case 'celebration':
        return ['#FFD700', '#FFA500'];
      case 'sad':
        return ['#87CEEB', '#4682B4'];
      case 'warning':
        return ['#FF6B6B', '#FF4444'];
      default:
        return ['#FF9F1C', '#FFD699'];
    }
  };

  const handleButtonPress = (button: any) => {
    if (hideTimer.current) {
      clearTimeout(hideTimer.current);
    }
    button.onPress();
  };

  if (!showModal) return null;

  return (
    <Modal
      transparent
      visible={showModal}
      onRequestClose={onDismiss}
      animationType="none"
    >
      <Animated.View 
        style={[
          styles.overlay,
          { opacity: fadeAnim }
        ]}
      >
        <TouchableOpacity 
          style={styles.overlayTouch} 
          activeOpacity={1} 
          onPress={onDismiss}
        />
        
        <Animated.View
          style={[
            styles.modalContainer,
            {
              transform: [
                { scale: scaleAnim },
                { translateY: bounceAnim }
              ],
            },
          ]}
        >
          <LinearGradient
            colors={getGradientColors()}
            style={styles.gradient}
            start={{ x: 0, y: 0 }}
            end={{ x: 1, y: 1 }}
          >
            {/* Particles */}
            {(type === 'celebration' || (type === 'excited' && reward)) &&
              particleAnims.map((anim, index) => (
                <Animated.View
                  key={index}
                  style={[
                    styles.particle,
                    {
                      opacity: anim.opacity,
                      transform: [
                        { translateX: anim.x },
                        { translateY: anim.y },
                        { scale: anim.scale },
                      ],
                    },
                  ]}
                >
                  <Text style={styles.particleEmoji}>
                    {['üåü', '‚ú®', 'üí´', '‚≠ê', 'üéä', 'üéà'][index]}
                  </Text>
                </Animated.View>
              ))
            }
            
            {/* Mascot */}
            <View style={styles.mascotContainer}>
              <Text style={styles.mascotEmoji}>{getMascotEmoji()}</Text>
            </View>
            
            {/* Content */}
            <View style={styles.content}>
              {title && <Text style={styles.title}>{title}</Text>}
              <Text style={styles.message}>{message}</Text>
              
              {reward && (
                <View style={styles.rewardContainer}>
                  <Icon name="clock-plus-outline" size={24} color="#FFF" />
                  <Text style={styles.rewardText}>+{reward} minutes!</Text>
                </View>
              )}
            </View>
            
            {/* Buttons */}
            {buttons && buttons.length > 0 && (
              <View style={styles.buttonContainer}>
                {buttons.map((button, index) => (
                  <TouchableOpacity
                    key={index}
                    style={[
                      styles.button,
                      button.style === 'primary' && styles.primaryButton,
                      button.style === 'secondary' && styles.secondaryButton,
                      button.style === 'danger' && styles.dangerButton,
                    ]}
                    onPress={() => handleButtonPress(button)}
                  >
                    <Text
                      style={[
                        styles.buttonText,
                        button.style === 'secondary' && styles.secondaryButtonText,
                      ]}
                    >
                      {button.text}
                    </Text>
                  </TouchableOpacity>
                ))}
              </View>
            )}
          </LinearGradient>
        </Animated.View>
      </Animated.View>
    </Modal>
  );
};

const styles = StyleSheet.create({
  overlay: {
    flex: 1,
    backgroundColor: 'rgba(0, 0, 0, 0.5)',
    justifyContent: 'center',
    alignItems: 'center',
  },
  overlayTouch: {
    ...StyleSheet.absoluteFillObject,
  },
  modalContainer: {
    width: width * 0.85,
    maxWidth: 400,
    borderRadius: 24,
    overflow: 'hidden',
    elevation: 10,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 4 },
    shadowOpacity: 0.3,
    shadowRadius: 8,
  },
  gradient: {
    padding: 24,
    alignItems: 'center',
  },
  mascotContainer: {
    marginBottom: 16,
  },
  mascotEmoji: {
    fontSize: 64,
  },
  content: {
    alignItems: 'center',
  },
  title: {
    fontSize: 24,
    fontWeight: 'bold',
    color: '#FFF',
    marginBottom: 8,
    textAlign: 'center',
    fontFamily: Platform.OS === 'ios' ? 'Avenir-Heavy' : 'sans-serif-black',
  },
  message: {
    fontSize: 16,
    color: '#FFF',
    textAlign: 'center',
    lineHeight: 24,
    fontFamily: Platform.OS === 'ios' ? 'Avenir-Medium' : 'sans-serif-medium',
  },
  rewardContainer: {
    flexDirection: 'row',
    alignItems: 'center',
    marginTop: 16,
    backgroundColor: 'rgba(255, 255, 255, 0.2)',
    paddingHorizontal: 16,
    paddingVertical: 8,
    borderRadius: 20,
  },
  rewardText: {
    fontSize: 18,
    fontWeight: 'bold',
    color: '#FFF',
    marginLeft: 8,
    fontFamily: Platform.OS === 'ios' ? 'Avenir-Heavy' : 'sans-serif-black',
  },
  buttonContainer: {
    marginTop: 24,
    width: '100%',
    gap: 12,
  },
  button: {
    paddingVertical: 14,
    paddingHorizontal: 24,
    borderRadius: 12,
    alignItems: 'center',
  },
  primaryButton: {
    backgroundColor: '#FFF',
  },
  secondaryButton: {
    backgroundColor: 'rgba(255, 255, 255, 0.2)',
    borderWidth: 2,
    borderColor: '#FFF',
  },
  dangerButton: {
    backgroundColor: '#FF4444',
  },
  buttonText: {
    fontSize: 16,
    fontWeight: 'bold',
    color: '#FF9F1C',
    fontFamily: Platform.OS === 'ios' ? 'Avenir-Heavy' : 'sans-serif-black',
  },
  secondaryButtonText: {
    color: '#FFF',
  },
  particle: {
    position: 'absolute',
    top: '50%',
    left: '50%',
  },
  particleEmoji: {
    fontSize: 24,
  },
});

export default MascotModal;

2. COMPREHENSIVE QUIZ SCREEN WITH TIMING GAPS
Update src/screens/QuizScreen.tsx - Add comprehensive timing delays:

// src/screens/QuizScreen.tsx - Partial update for timing and daily goals
// Add these imports at the top
import MascotModal from '../components/Mascot/MascotModal';
import { useQuizStore } from '../store/useQuizStore';
import DailyGoalsService from '../services/DailyGoalsService';

// Add these state variables
const [showDailyGoalModal, setShowDailyGoalModal] = useState(false);
const [completedGoal, setCompletedGoal] = useState<{title: string, reward: number} | null>(null);
const [showingQuestion, setShowingQuestion] = useState(false);
const [showingOptions, setShowingOptions] = useState(false);
const [timerStarted, setTimerStarted] = useState(false);
const [readyForInput, setReadyForInput] = useState(false);

// Replace the entire loadQuestion function
const loadQuestion = async () => {
  try {
    setIsLoading(true);
    setSelectedAnswer(null);
    setIsCorrect(null);
    setShowExplanation(false);
    setSpeedCategory('');
    setPointsEarned(0);
    setMultiplier(1);
    setShowingQuestion(false);
    setShowingOptions(false);
    setTimerStarted(false);
    setReadyForInput(false);
    
    // Reset all animations
    fadeAnim.setValue(0);
    cardAnim.setValue(0);
    explanationAnim.setValue(0);
    optionsAnim.forEach(anim => anim?.setValue(0));
    timerAnim.setValue(1);
    
    // Stop any running timers
    if (timerAnimation.current) {
      timerAnimation.current.stop();
    }
    if (timerRef.current) {
      clearTimeout(timerRef.current);
    }
    
    // Get the question
    const question = await QuizAPI.getQuestion(category, difficulty);
    if (!question) {
      throw new Error('No question received');
    }
    
    setCurrentQuestion(question);
    setIsLoading(false);
    
    // STEP 1: Fade in the question card (1 second)
    await new Promise((resolve) => {
      setShowingQuestion(true);
      Animated.parallel([
        Animated.timing(fadeAnim, {
          toValue: 1,
          duration: 600,
          useNativeDriver: true,
          easing: Easing.out(Easing.cubic),
        }),
        Animated.spring(cardAnim, {
          toValue: 1,
          delay: 200,
          friction: 8,
          tension: 40,
          useNativeDriver: true,
        }),
      ]).start(() => resolve(undefined));
    });
    
    // STEP 2: Let user read the question (3 seconds)
    await new Promise(resolve => setTimeout(resolve, 3000));
    
    // STEP 3: Show "Get Ready!" message (optional)
    // You could show a countdown here: 3... 2... 1...
    
    // STEP 4: Animate options in with stagger (1.5 seconds total)
    const optionKeys = Object.keys(question.options || {});
    optionsAnim.length = optionKeys.length;
    for (let i = 0; i < optionsAnim.length; i++) {
      optionsAnim[i] = new Animated.Value(0);
    }
    
    setShowingOptions(true);
    
    await new Promise((resolve) => {
      const animations = optionsAnim.map((anim, index) => 
        Animated.sequence([
          Animated.delay(index * 200), // Stagger by 200ms
          Animated.spring(anim, {
            toValue: 1,
            friction: 6,
            tension: 40,
            useNativeDriver: true,
          }),
        ])
      );
      
      Animated.parallel(animations).start(() => resolve(undefined));
    });
    
    // STEP 5: Brief pause before starting timer (500ms)
    await new Promise(resolve => setTimeout(resolve, 500));
    
    // STEP 6: Start the timer and enable input
    setTimerStarted(true);
    setReadyForInput(true);
    questionStartTime.current = Date.now();
    
    // Animate timer countdown
    timerAnimation.current = Animated.timing(timerAnim, {
      toValue: 0,
      duration: 20000,
      useNativeDriver: false,
      easing: Easing.linear,
    });
    
    timerAnimation.current.start();
    
    // Set timeout for time up
    timerRef.current = setTimeout(() => {
      if (selectedAnswer === null) {
        handleTimeUp();
      }
    }, 20000);
    
  } catch (error) {
    console.error('Error loading question:', error);
    setIsLoading(false);
  }
};

// Update handleAnswerSelect with better timing
const handleAnswerSelect = async (answer: string) => {
  // Don't accept input until ready
  if (!readyForInput || selectedAnswer !== null || isLoading) return;
  
  setReadyForInput(false); // Disable further input
  
  // Stop timer immediately
  if (timerAnimation.current) {
    timerAnimation.current.stop();
  }
  if (timerRef.current) {
    clearTimeout(timerRef.current);
  }
  
  // Play selection sound
  SoundService.playButtonPress();
  
  setSelectedAnswer(answer);
  const correct = answer === currentQuestion?.correctAnswer;
  setIsCorrect(correct);
  
  // STEP 1: Show selection feedback (500ms)
  await new Promise(resolve => setTimeout(resolve, 500));
  
  // STEP 2: Show multiplier animation (500ms)
  const responseTime = Date.now() - questionStartTime.current;
  const speedMultiplier = calculateSpeedMultiplier(responseTime);
  setMultiplier(speedMultiplier);
  
  pointsAnim.setValue(0);
  speedAnim.setValue(0);
  
  await new Promise((resolve) => {
    Animated.sequence([
      Animated.spring(pointsAnim, {
        toValue: 1,
        friction: 5,
        tension: 50,
        useNativeDriver: true,
      }),
      Animated.delay(500),
      Animated.spring(speedAnim, {
        toValue: 1,
        friction: 5,
        tension: 50,
        useNativeDriver: true,
      }),
    ]).start(() => resolve(undefined));
  });
  
  // STEP 3: Update score with animation (500ms)
  await new Promise(resolve => setTimeout(resolve, 500));
  
  // Process the scoring
  await processScoring(correct);
  
  // STEP 4: Show explanation after a delay (1 second)
  await new Promise(resolve => setTimeout(resolve, 1000));
  
  setShowExplanation(true);
  Animated.timing(explanationAnim, {
    toValue: 1,
    duration: 400,
    useNativeDriver: true,
    easing: Easing.out(Easing.cubic),
  }).start();
};

// Update the daily goal completion check
const checkDailyGoalCompletion = async (isCorrect: boolean, quizDifficulty: string, quizCategory: string) => {
  try {
    const accuracy = questionsAnswered > 0 ? Math.round((correctAnswers / questionsAnswered) * 100) : 0;
    
    // Update progress
    await DailyGoalsService.updateProgress({
      isCorrect: isCorrect,
      difficulty: quizDifficulty || 'medium',
      category: quizCategory || 'general',
      todayQuestions: questionsAnswered + 1,
      currentStreak: streak || 0,
      todayAccuracy: accuracy
    });
    
    // Get unclaimed completed goals
    const goals = DailyGoalsService.getGoals();
    const unclaimedGoals = goals.filter(goal => goal.completed && !goal.claimed);
    
    if (unclaimedGoals.length > 0) {
      const goal = unclaimedGoals[0];
      
      console.log(`üéØ Goal completed: ${goal.title}`);
      
      // Show the modal immediately
      setCompletedGoal({
        title: goal.title,
        reward: goal.reward
      });
      setShowDailyGoalModal(true);
      
      // Mark as notified
      goal.notified = true;
      await DailyGoalsService.saveGoals();
    }
  } catch (error) {
    console.error('Error checking daily goal completion:', error);
  }
};

// Update handleDailyGoalClaim
const handleDailyGoalClaim = async () => {
  if (!completedGoal) return;
  
  try {
    // Find and claim the goal
    const goals = DailyGoalsService.getGoals();
    const goalToClaim = goals.find(g => g.title === completedGoal.title && g.completed && !g.claimed);
    
    if (goalToClaim) {
      // Claim the reward (this adds time to timer internally)
      const success = await DailyGoalsService.claimReward(goalToClaim.id);
      
      if (success) {
        console.log(`‚úÖ Claimed daily goal: ${goalToClaim.title}`);
        
        // The time has been added by DailyGoalsService
        // Just play success sound
        SoundService.playStreak();
      }
    }
  } catch (error) {
    console.error('Error claiming daily goal:', error);
  } finally {
    // Always close the modal
    setShowDailyGoalModal(false);
    setCompletedGoal(null);
  }
};

// In the useEffect for initialization
useEffect(() => {
  const initializeQuiz = async () => {
    console.log('üéÆ Initializing quiz session');
    
    // CRITICAL: Initialize quiz session (sets streak to 0)
    await useQuizStore.getState().initializeQuizSession();
    setStreak(0); // Ensure local state matches
    
    // Initialize services
    await DailyGoalsService.initialize();
    
    // Initialize audio
    await initializeAudio();
    
    // Load first question
    loadQuestion();
  };
  
  initializeQuiz();
  
  return () => {
    console.log('üéÆ Cleaning up quiz session');
    SoundService.stopMusic();
  };
}, []);

// Add the modal to the JSX (at the bottom before closing SafeAreaView)
{showDailyGoalModal && completedGoal && (
  <MascotModal
    visible={showDailyGoalModal}
    type="celebration"
    title="üéØ Goal Complete!"
    message={`Amazing! You completed "${completedGoal.title}"!`}
    reward={Math.floor(completedGoal.reward / 60)}
    onDismiss={() => {
      setShowDailyGoalModal(false);
      setCompletedGoal(null);
    }}
    buttons={[
      {
        text: "Claim Reward!",
        onPress: handleDailyGoalClaim,
        style: 'primary'
      }
    ]}
    autoHide={false}
  />
)}

// In the render, conditionally show options based on state
{showingOptions && currentQuestion?.options && Object.entries(currentQuestion.options).map(([key, value], index) => (
  <Animated.View
    key={key}
    style={{
      opacity: optionsAnim[index] || new Animated.Value(0),
      transform: [
        { 
          translateY: (optionsAnim[index] || new Animated.Value(0)).interpolate({
            inputRange: [0, 1],
            outputRange: [20, 0]
          })
        },
        {
          scale: (optionsAnim[index] || new Animated.Value(0)).interpolate({
            inputRange: [0, 1],
            outputRange: [0.8, 1]
          })
        }
      ]
    }}
  >
    <TouchableOpacity
      style={[
        styles.optionButton,
        selectedAnswer === key && (
          key === currentQuestion.correctAnswer ? 
            styles.correctAnswer : 
            styles.incorrectAnswer
        ),
        !readyForInput && styles.disabledOption
      ]}
      onPress={() => handleAnswerSelect(key)}
      disabled={!readyForInput || selectedAnswer !== null}
    >
      {/* Option content */}
    </TouchableOpacity>
  </Animated.View>
))}

// Add disabled option style
const styles = StyleSheet.create({
  // ... existing styles ...
  disabledOption: {
    opacity: 0.6,
  },
});


3. FIX STREAK LOGIC & HOME SCREEN DISPLAY
Update src/screens/HomeScreen.tsx - Fix highest streak display:
javascript// Add to imports
import { useQuizStore } from '../store/useQuizStore';

// In the component, add this to get the daily highest streak
const { dailyHighestStreak } = useQuizStore();

// In the useEffect or useFocusEffect
useFocusEffect(
  React.useCallback(() => {
    const loadData = async () => {
      // Load the daily highest streak
      await useQuizStore.getState().loadDailyHighest();
      
      // Rest of your refresh logic
      handleRefresh();
    };
    
    loadData();
  }, [])
);

// Update the streak display in JSX
<View style={styles.streakContainer}>
  <Icon name="fire" size={24} color="#FF9F1C" />
  <Text style={styles.streakText}>
    Best Streak Today: {dailyHighestStreak || 0}
  </Text>
</View>
Update src/screens/LeaderboardScreen.tsx - Use correct streak value:
javascript// Import the store
import { useQuizStore } from '../store/useQuizStore';

// Get the daily highest
const { dailyHighestStreak } = useQuizStore();

// Use it in the display
<Text style={styles.userStreak}>
  Streak: {dailyHighestStreak || 0} üî•
</Text>
4. FIX NOTIFICATION SOUNDS (Only Silent for Persistent)
Update android/app/src/main/java/com/brainbites/timer/ScreenTimeService.kt:
kotlin// Update createNotificationChannel to have TWO channels
private fun createNotificationChannel() {
    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
        val notificationManager = getSystemService(Context.NOTIFICATION_SERVICE) as NotificationManager
        
        // Channel 1: Silent persistent notification
        val silentChannel = NotificationChannel(
            CHANNEL_ID,
            "Timer Tracking",
            NotificationManager.IMPORTANCE_LOW
        ).apply {
            description = "Silent timer tracking"
            setSound(null, null) // No sound
            enableVibration(false)
            setShowBadge(false)
        }
        
        // Channel 2: Alert notifications (with sound)
        val alertChannel = NotificationChannel(
            "brainbites_alerts",
            "Timer Alerts",
            NotificationManager.IMPORTANCE_HIGH
        ).apply {
            description = "Timer warnings and alerts"
            enableVibration(true)
            setShowBadge(true)
            // Default sound will be used
        }
        
        notificationManager.createNotificationChannel(silentChannel)
        notificationManager.createNotificationChannel(alertChannel)
    }
}

// Update createPersistentNotification to ensure it's silent
private fun createPersistentNotification(): Notification {
    // ... existing code ...
    
    val builder = NotificationCompat.Builder(this, CHANNEL_ID) // Use silent channel
        .setSmallIcon(R.drawable.ic_notification)
        .setOngoing(true)
        .setPriority(NotificationCompat.PRIORITY_LOW)
        .setSilent(true) // Explicitly silent
        .setOnlyAlertOnce(true)
        .setContentIntent(pendingIntent)
    
    // ... rest of existing code ...
}

// Update warning notifications to use alert channel
private fun showLowTimeNotification(minutes: Int) {
    try {
        val notification = NotificationCompat.Builder(this, "brainbites_alerts") // Alert channel
            .setSmallIcon(R.drawable.ic_notification)
            .setContentTitle("‚è±Ô∏è CaBBy Says: Time Check!")
            .setContentText("Only $minutes minutes left!")
            .setPriority(NotificationCompat.PRIORITY_HIGH)
            .setDefaults(NotificationCompat.DEFAULT_ALL) // Sound + Vibration
            .setAutoCancel(true)
            .build()
            
        notificationManagerCompat.notify(1000 + minutes, notification)
    } catch (e: Exception) {
        Log.e(TAG, "Failed to show warning", e)
    }
}

private fun showTimeExpiredNotification() {
    try {
        val notification = NotificationCompat.Builder(this, "brainbites_alerts") // Alert channel
            .setSmallIcon(R.drawable.ic_notification)
            .setContentTitle("üéØ Time's Up!")
            .setContentText("Come earn more time!")
            .setPriority(NotificationCompat.PRIORITY_HIGH)
            .setDefaults(NotificationCompat.DEFAULT_ALL) // Sound + Vibration
            .setAutoCancel(true)
            .build()
            
        notificationManagerCompat.notify(999, notification)
    } catch (e: Exception) {
        Log.e(TAG, "Failed to show expired notification", e)
    }
}
5. FIX OVERTIME LOGIC TO PERSIST
Update src/services/HybridTimerService.ts:
javascriptclass HybridTimerService {
  // Add these properties
  private overtimeSeconds: number = 0;
  private overtimePaused: boolean = false;
  private overtimePausedAt: number = 0;
  
  // Update initialize to load overtime
  async initialize(): Promise<boolean> {
    try {
      // ... existing initialization ...
      
      // Load overtime from storage
      const savedOvertime = await AsyncStorage.getItem('@BrainBites:overtime');
      const savedOvertimePaused = await AsyncStorage.getItem('@BrainBites:overtimePaused');
      
      if (savedOvertime) {
        this.overtimeSeconds = parseInt(savedOvertime, 10);
      }
      if (savedOvertimePaused === 'true') {
        this.overtimePaused = true;
        const pausedAt = await AsyncStorage.getItem('@BrainBites:overtimePausedAt');
        this.overtimePausedAt = pausedAt ? parseInt(pausedAt, 10) : 0;
      }
      
      console.log(`‚è∞ Loaded overtime: ${this.overtimeSeconds}s (paused: ${this.overtimePaused})`);
      
      return true;
    } catch (error) {
      console.error('Failed to initialize:', error);
      return false;
    }
  }
  
  // Update addTimeFromQuiz to pause but not reset overtime
  async addTimeFromQuiz(minutes: number): Promise<boolean> {
    try {
      const secondsToAdd = minutes * 60;
      
      // If we have overtime and it's not paused, pause it
      if (this.overtimeSeconds > 0 && !this.overtimePaused) {
        this.overtimePaused = true;
        this.overtimePausedAt = this.overtimeSeconds;
        await AsyncStorage.setItem('@BrainBites:overtimePaused', 'true');
        await AsyncStorage.setItem('@BrainBites:overtimePausedAt', this.overtimeSeconds.toString());
        console.log(`‚è∏Ô∏è Pausing overtime at ${this.overtimeSeconds}s`);
      }
      
      // Add time to remaining
      const currentRemaining = this.currentData?.remainingTime || 0;
      const newRemaining = currentRemaining + secondsToAdd;
      
      // Call native module
      const success = await this.callNativeAddTime(minutes);
      
      if (success && this.currentData) {
        this.currentData = {
          ...this.currentData,
          remainingTime: newRemaining,
          overtime: this.overtimeSeconds // Keep overtime value
        };
        this.notifyListeners();
      }
      
      return success;
    } catch (error) {
      console.error('Failed to add time:', error);
      return false;
    }
  }
  
  // Add method to handle timer updates
  private async handleTimerTick(): Promise<void> {
    if (!this.currentData) return;
    
    const { remainingTime } = this.currentData;
    
    // If time runs out and overtime was paused, resume it
    if (remainingTime <= 0 && this.overtimePaused && this.overtimePausedAt > 0) {
      this.overtimeSeconds = this.overtimePausedAt;
      this.overtimePaused = false;
      this.overtimePausedAt = 0;
      await AsyncStorage.setItem('@BrainBites:overtimePaused', 'false');
      await AsyncStorage.removeItem('@BrainBites:overtimePausedAt');
      console.log(`‚ñ∂Ô∏è Resuming overtime at ${this.overtimeSeconds}s`);
    }
    
    // If in overtime mode (not paused), increment overtime
    if (remainingTime <= 0 && !this.overtimePaused) {
      this.overtimeSeconds++;
      await AsyncStorage.setItem('@BrainBites:overtime', this.overtimeSeconds.toString());
    }
    
    // Update current data with overtime
    this.currentData = {
      ...this.currentData,
      overtime: this.overtimeSeconds
    };
  }
  
  // Add method to reset overtime (only on new day)
  async resetDailyOvertime(): Promise<void> {
    const today = new Date().toDateString();
    const lastReset = await AsyncStorage.getItem('@BrainBites:lastOvertimeReset');
    
    if (lastReset !== today) {
      this.overtimeSeconds = 0;
      this.overtimePaused = false;
      this.overtimePausedAt = 0;
      await AsyncStorage.setItem('@BrainBites:overtime', '0');
      await AsyncStorage.setItem('@BrainBites:overtimePaused', 'false');
      await AsyncStorage.removeItem('@BrainBites:overtimePausedAt');
      await AsyncStorage.setItem('@BrainBites:lastOvertimeReset', today);
      console.log('üåÖ New day - overtime reset');
    }
  }
}
Update Android ScreenTimeService.kt to track overtime properly:
kotlin// Add overtime tracking properties
private var overtimeSeconds = 0
private var overtimePaused = false
private var overtimePausedAt = 0

// In onCreate, load overtime
override fun onCreate() {
    super.onCreate()
    // ... existing code ...
    
    // Load overtime
    overtimeSeconds = sharedPrefs.getInt(KEY_OVERTIME, 0)
    overtimePaused = sharedPrefs.getBoolean("overtime_paused", false)
    overtimePausedAt = sharedPrefs.getInt("overtime_paused_at", 0)
    
    Log.d(TAG, "Loaded overtime: ${overtimeSeconds}s (paused: $overtimePaused)")
}

// Update addTime to handle overtime
private fun addTime(seconds: Int) {
    // If we have overtime and it's not paused, pause it
    if (overtimeSeconds > 0 && !overtimePaused) {
        overtimePaused = true
        overtimePausedAt = overtimeSeconds
        sharedPrefs.edit()
            .putBoolean("overtime_paused", true)
            .putInt("overtime_paused_at", overtimeSeconds)
            .apply()
        Log.d(TAG, "Pausing overtime at ${overtimeSeconds}s")
    }
    
    remainingTimeSeconds += seconds
    saveData()
    updatePersistentNotification()
    broadcastUpdate()
}

// In updateTimer when time runs out
private fun updateTimer() {
    // ... existing timer logic ...
    
    if (remainingTimeSeconds <= 0) {
        // Resume paused overtime if applicable
        if (overtimePaused && overtimePausedAt > 0) {
            overtimeSeconds = overtimePausedAt
            overtimePaused = false
            overtimePausedAt = 0
            sharedPrefs.edit()
                .putBoolean("overtime_paused", false)
                .remove("overtime_paused_at")
                .apply()
            Log.d(TAG, "Resuming overtime at ${overtimeSeconds}s")
        }
        
        // Increment overtime if not paused
        if (!overtimePaused) {
            overtimeSeconds++
            sharedPrefs.edit()
                .putInt(KEY_OVERTIME, overtimeSeconds)
                .apply()
        }
    }
}

// Update notification to show overtime
private fun createPersistentNotification(): Notification {
    // ... existing code ...
    
    val expandedText = buildString {
        append("Time left: $timeLeftStr\n")
        append("Screen time: $screenTimeStr")
        if (overtimeSeconds > 0) {
            append("\nOvertime: ${formatTime(overtimeSeconds)}")
            if (overtimePaused) append(" (paused)")
        }
    }
    
    // ... rest of notification code ...
}
These comprehensive updates should fix all 5 issues. The key changes are:

MascotModal is properly integrated with celebration animations and reward display
Quiz timing now has proper gaps between question, options, and timer start
Streak logic properly uses dailyHighestStreak from the store
Notifications use separate channels for silent persistent and alert notifications
Overtime persists throughout the day and pauses/resumes correctly when time is added