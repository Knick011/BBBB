# BrainBites Timer & Notification Fixes

## Issues Identified

1. **Timed notifications (7:30 AM, 12 PM, evening) not showing**
2. **Persistent timer notification dies after 6 hours** 
3. **Negative score carryover verification needed**

## Fix 1: Scheduled Notifications (7:30 AM, 12 PM, Evening)

### Update `android/app/src/main/java/com/brainbitescabby/app/modules/NotificationModule.kt`

Add the `scheduleOneTimeNotification` method that's missing:

```kotlin
package com.brainbitescabby.app.modules

import android.app.AlarmManager
import android.app.NotificationChannel
import android.app.NotificationManager
import android.app.PendingIntent
import android.content.Context
import android.content.Intent
import android.os.Build
import android.util.Log
import androidx.core.app.NotificationCompat
import com.brainbitescabby.app.R
import com.brainbitescabby.app.receivers.MorningNotificationReceiver
import com.brainbitescabby.app.receivers.ScheduledNotificationReceiver
import com.facebook.react.bridge.*
import org.json.JSONObject
import java.util.Calendar

class NotificationModule(reactContext: ReactApplicationContext) : ReactContextBaseJavaModule(reactContext) {
    
    companion object {
        private const val TAG = "NotificationModule"
        private const val CHANNEL_ID = "brainbites_scheduled"
        private const val MORNING_NOTIFICATION_ID = 9001
    }
    
    override fun getName() = "NotificationModule"
    
    @ReactMethod
    fun scheduleOneTimeNotification(
        timestamp: Double,
        title: String,
        body: String,
        notificationId: String,
        data: ReadableMap,
        promise: Promise
    ) {
        try {
            val context = reactApplicationContext
            val alarmManager = context.getSystemService(Context.ALARM_SERVICE) as AlarmManager
            
            Log.d(TAG, "Scheduling one-time notification '$notificationId' for timestamp: $timestamp")
            
            // Convert ReadableMap to JSON string
            val dataJson = JSONObject()
            val iterator = data.keySetIterator()
            while (iterator.hasNextKey()) {
                val key = iterator.nextKey()
                when (data.getType(key)) {
                    ReadableType.String -> dataJson.put(key, data.getString(key))
                    ReadableType.Number -> dataJson.put(key, data.getDouble(key))
                    ReadableType.Boolean -> dataJson.put(key, data.getBoolean(key))
                    else -> {}
                }
            }
            
            val intent = Intent(context, ScheduledNotificationReceiver::class.java).apply {
                putExtra("notification_id", notificationId)
                putExtra("title", title)
                putExtra("body", body)
                putExtra("data", dataJson.toString())
            }
            
            val pendingIntent = PendingIntent.getBroadcast(
                context,
                notificationId.hashCode(),
                intent,
                PendingIntent.FLAG_UPDATE_CURRENT or PendingIntent.FLAG_IMMUTABLE
            )
            
            // Schedule the notification
            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.M) {
                alarmManager.setExactAndAllowWhileIdle(
                    AlarmManager.RTC_WAKEUP,
                    timestamp.toLong(),
                    pendingIntent
                )
            } else {
                alarmManager.setExact(
                    AlarmManager.RTC_WAKEUP,
                    timestamp.toLong(),
                    pendingIntent
                )
            }
            
            Log.d(TAG, "âœ… One-time notification scheduled successfully")
            promise.resolve(true)
            
        } catch (e: Exception) {
            Log.e(TAG, "Failed to schedule one-time notification", e)
            promise.reject("SCHEDULE_ERROR", e.message, e)
        }
    }
    
    @ReactMethod
    fun cancelScheduledNotification(notificationId: String, promise: Promise) {
        try {
            val context = reactApplicationContext
            val alarmManager = context.getSystemService(Context.ALARM_SERVICE) as AlarmManager
            
            val intent = Intent(context, ScheduledNotificationReceiver::class.java)
            val pendingIntent = PendingIntent.getBroadcast(
                context,
                notificationId.hashCode(),
                intent,
                PendingIntent.FLAG_UPDATE_CURRENT or PendingIntent.FLAG_IMMUTABLE
            )
            
            alarmManager.cancel(pendingIntent)
            Log.d(TAG, "âœ… Cancelled scheduled notification: $notificationId")
            promise.resolve(true)
            
        } catch (e: Exception) {
            Log.e(TAG, "Failed to cancel scheduled notification", e)
            promise.reject("CANCEL_ERROR", e.message, e)
        }
    }

    // ... rest of existing methods (scheduleMorningReminder, etc.)
}
```

### Create `android/app/src/main/java/com/brainbitescabby/app/receivers/ScheduledNotificationReceiver.kt`

```kotlin
package com.brainbitescabby.app.receivers

import android.app.NotificationChannel
import android.app.NotificationManager
import android.app.PendingIntent
import android.content.BroadcastReceiver
import android.content.Context
import android.content.Intent
import android.os.Build
import android.util.Log
import androidx.core.app.NotificationCompat
import com.brainbitescabby.app.MainActivity
import com.brainbitescabby.app.R
import org.json.JSONObject

class ScheduledNotificationReceiver : BroadcastReceiver() {
    
    companion object {
        private const val TAG = "ScheduledNotification"
        private const val CHANNEL_ID = "brainbites_scheduled"
    }
    
    override fun onReceive(context: Context, intent: Intent) {
        val notificationId = intent.getStringExtra("notification_id") ?: "default"
        val title = intent.getStringExtra("title") ?: "BrainBites"
        val body = intent.getStringExtra("body") ?: ""
        val dataString = intent.getStringExtra("data")
        
        Log.d(TAG, "Received scheduled notification: $notificationId")
        
        showNotification(context, notificationId, title, body, dataString)
    }
    
    private fun showNotification(
        context: Context, 
        notificationId: String,
        title: String, 
        body: String,
        dataString: String?
    ) {
        val notificationManager = context.getSystemService(Context.NOTIFICATION_SERVICE) as NotificationManager
        
        // Create notification channel
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
            val channel = NotificationChannel(
                CHANNEL_ID,
                "Scheduled Notifications",
                NotificationManager.IMPORTANCE_HIGH
            ).apply {
                description = "Daily reminders and leaderboard nudges"
                enableVibration(true)
                enableLights(true)
            }
            notificationManager.createNotificationChannel(channel)
        }
        
        // Create intent to open app
        val mainIntent = Intent(context, MainActivity::class.java).apply {
            flags = Intent.FLAG_ACTIVITY_NEW_TASK or Intent.FLAG_ACTIVITY_CLEAR_TOP
            dataString?.let {
                putExtra("notification_data", it)
            }
        }
        
        val pendingIntent = PendingIntent.getActivity(
            context,
            0,
            mainIntent,
            PendingIntent.FLAG_UPDATE_CURRENT or PendingIntent.FLAG_IMMUTABLE
        )
        
        // Build notification
        val notification = NotificationCompat.Builder(context, CHANNEL_ID)
            .setSmallIcon(R.drawable.ic_notification)
            .setContentTitle(title)
            .setContentText(body)
            .setStyle(NotificationCompat.BigTextStyle().bigText(body))
            .setPriority(NotificationCompat.PRIORITY_HIGH)
            .setAutoCancel(true)
            .setDefaults(NotificationCompat.DEFAULT_ALL)
            .setContentIntent(pendingIntent)
            .build()
        
        notificationManager.notify(notificationId.hashCode(), notification)
        Log.d(TAG, "âœ… Notification displayed: $title")
    }
}
```

## Fix 2: Persistent Timer Notification 6-Hour Death

The issue is that Android's Doze mode and background restrictions kill services after ~6 hours. We need to implement:
1. JobScheduler for periodic service restart
2. AlarmManager with setAlarmClock for critical wakeups
3. Proper wakelock management

### Update `android/app/src/main/java/com/brainbitescabby/app/timer/ScreenTimeService.kt`

Add these key changes to prevent the 6-hour death:

```kotlin
class ScreenTimeService : Service() {
    // ... existing properties ...
    
    private var serviceRestartJob: JobInfo? = null
    private lateinit var jobScheduler: JobScheduler
    private lateinit var alarmManager: AlarmManager
    private var criticalWakeupIntent: PendingIntent? = null
    
    companion object {
        // ... existing constants ...
        private const val MAX_SERVICE_LIFETIME_MS = 16 * 60 * 60 * 1000L // 16 hours
        private const val SERVICE_RESTART_JOB_ID = 12345
        private const val CRITICAL_WAKEUP_INTERVAL = 2 * 60 * 60 * 1000L // 2 hours
    }
    
    override fun onCreate() {
        super.onCreate()
        // ... existing initialization ...
        
        jobScheduler = getSystemService(Context.JOB_SCHEDULER_SERVICE) as JobScheduler
        alarmManager = getSystemService(Context.ALARM_SERVICE) as AlarmManager
        
        // Schedule periodic restart job
        scheduleServiceRestartJob()
        
        // Schedule critical wakeup alarms
        scheduleCriticalWakeup()
    }
    
    private fun scheduleServiceRestartJob() {
        val componentName = ComponentName(this, TimerRestartJobService::class.java)
        
        val jobInfo = JobInfo.Builder(SERVICE_RESTART_JOB_ID, componentName)
            .setPeriodic(CRITICAL_WAKEUP_INTERVAL) // Every 2 hours
            .setPersisted(true) // Survives reboot
            .setRequiresDeviceIdle(false)
            .build()
            
        val result = jobScheduler.schedule(jobInfo)
        if (result == JobScheduler.RESULT_SUCCESS) {
            Log.d(TAG, "âœ… Service restart job scheduled")
        }
    }
    
    private fun scheduleCriticalWakeup() {
        // Cancel any existing alarm
        criticalWakeupIntent?.let { alarmManager.cancel(it) }
        
        val intent = Intent(this, TimerWakeupReceiver::class.java)
        criticalWakeupIntent = PendingIntent.getBroadcast(
            this,
            0,
            intent,
            PendingIntent.FLAG_UPDATE_CURRENT or PendingIntent.FLAG_IMMUTABLE
        )
        
        val triggerTime = System.currentTimeMillis() + CRITICAL_WAKEUP_INTERVAL
        
        // Use setAlarmClock for critical wakeup that bypasses Doze
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP) {
            val showIntent = PendingIntent.getActivity(
                this,
                0,
                Intent(this, MainActivity::class.java),
                PendingIntent.FLAG_UPDATE_CURRENT or PendingIntent.FLAG_IMMUTABLE
            )
            
            alarmManager.setAlarmClock(
                AlarmManager.AlarmClockInfo(triggerTime, showIntent),
                criticalWakeupIntent
            )
        } else {
            alarmManager.setExact(
                AlarmManager.RTC_WAKEUP,
                triggerTime,
                criticalWakeupIntent
            )
        }
        
        Log.d(TAG, "â° Critical wakeup scheduled for ${CRITICAL_WAKEUP_INTERVAL / 1000 / 60} minutes")
    }
    
    override fun onStartCommand(intent: Intent?, flags: Int, startId: Int): Int {
        // ... existing code ...
        
        // Check if service has been running too long
        if (serviceStartAtMs > 0) {
            val runningTime = System.currentTimeMillis() - serviceStartAtMs
            if (runningTime > MAX_SERVICE_LIFETIME_MS) {
                Log.w(TAG, "âš ï¸ Service running for ${runningTime / 1000 / 60 / 60}h, scheduling restart")
                scheduleDelayedRestart()
            }
        }
        
        return START_STICKY // Ensure service restarts if killed
    }
    
    private fun scheduleDelayedRestart() {
        // Save current state
        saveTimerData()
        
        // Schedule restart in 5 seconds
        handler.postDelayed({
            stopSelf()
            
            // Restart service
            val restartIntent = Intent(this, ScreenTimeService::class.java).apply {
                action = ACTION_START
            }
            
            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
                startForegroundService(restartIntent)
            } else {
                startService(restartIntent)
            }
        }, 5000)
    }
    
    // Enhanced wakelock management
    private fun acquireWakeLock() {
        try {
            if (wakeLock?.isHeld == true) {
                wakeLock?.release()
            }
            
            wakeLock = powerManager.newWakeLock(
                PowerManager.PARTIAL_WAKE_LOCK,
                "BrainBites::TimerWakeLock"
            ).apply {
                // Use a timeout to prevent battery drain
                acquire(10 * 60 * 1000L) // 10 minutes timeout
            }
            
            Log.d(TAG, "âœ… WakeLock acquired with timeout")
        } catch (e: Exception) {
            Log.e(TAG, "âŒ Failed to acquire wakelock", e)
        }
    }
    
    // Renew wakelock periodically
    private fun renewWakeLock() {
        handler.postDelayed({
            if (timerRunnable != null) {
                acquireWakeLock()
                renewWakeLock() // Schedule next renewal
            }
        }, 9 * 60 * 1000L) // Renew every 9 minutes
    }
}
```

### Create `android/app/src/main/java/com/brainbitescabby/app/timer/TimerRestartJobService.kt`

```kotlin
package com.brainbitescabby.app.timer

import android.app.job.JobParameters
import android.app.job.JobService
import android.content.Intent
import android.os.Build
import android.util.Log

class TimerRestartJobService : JobService() {
    
    companion object {
        private const val TAG = "TimerRestartJob"
    }
    
    override fun onStartJob(params: JobParameters): Boolean {
        Log.d(TAG, "â° Timer restart job triggered")
        
        // Check if service is running
        if (!ScreenTimeService.isServiceRunning()) {
            val prefs = getSharedPreferences("BrainBitesTimerPrefs", MODE_PRIVATE)
            val remainingTime = prefs.getInt("remaining_time", 0)
            
            if (remainingTime > 0) {
                Log.d(TAG, "ðŸ”„ Restarting timer service with ${remainingTime}s remaining")
                
                val serviceIntent = Intent(this, ScreenTimeService::class.java).apply {
                    action = ScreenTimeService.ACTION_START
                }
                
                if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
                    startForegroundService(serviceIntent)
                } else {
                    startService(serviceIntent)
                }
            }
        } else {
            Log.d(TAG, "âœ… Timer service already running")
        }
        
        return false // Job completed
    }
    
    override fun onStopJob(params: JobParameters): Boolean {
        return false // Don't reschedule
    }
}
```

### Create `android/app/src/main/java/com/brainbitescabby/app/timer/TimerWakeupReceiver.kt`

```kotlin
package com.brainbitescabby.app.timer

import android.content.BroadcastReceiver
import android.content.Context
import android.content.Intent
import android.os.Build
import android.util.Log

class TimerWakeupReceiver : BroadcastReceiver() {
    
    companion object {
        private const val TAG = "TimerWakeup"
    }
    
    override fun onReceive(context: Context, intent: Intent) {
        Log.d(TAG, "â° Critical wakeup received")
        
        // Check if service needs restart
        if (!ScreenTimeService.isServiceRunning()) {
            val prefs = context.getSharedPreferences("BrainBitesTimerPrefs", Context.MODE_PRIVATE)
            val remainingTime = prefs.getInt("remaining_time", 0)
            
            if (remainingTime > 0) {
                Log.d(TAG, "ðŸ”„ Waking up timer service")
                
                val serviceIntent = Intent(context, ScreenTimeService::class.java).apply {
                    action = ScreenTimeService.ACTION_START
                }
                
                try {
                    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
                        context.startForegroundService(serviceIntent)
                    } else {
                        context.startService(serviceIntent)
                    }
                } catch (e: Exception) {
                    Log.e(TAG, "Failed to start service from wakeup", e)
                }
            }
        }
        
        // Reschedule next wakeup
        val service = ScreenTimeService()
        service.scheduleCriticalWakeup()
    }
}
```

### Update `AndroidManifest.xml`

Add these new components:

```xml
<!-- Add inside <application> tag -->

<!-- Job Service for periodic restart -->
<service
    android:name="com.brainbitescabby.app.timer.TimerRestartJobService"
    android:permission="android.permission.BIND_JOB_SERVICE"
    android:exported="false" />

<!-- Scheduled Notification Receiver -->
<receiver
    android:name="com.brainbitescabby.app.receivers.ScheduledNotificationReceiver"
    android:enabled="true"
    android:exported="false" />

<!-- Timer Wakeup Receiver -->
<receiver
    android:name="com.brainbitescabby.app.timer.TimerWakeupReceiver"
    android:enabled="true"
    android:exported="false" />

<!-- Boot Receiver for timer restart -->
<receiver
    android:name="com.brainbitescabby.app.timer.BootReceiver"
    android:enabled="true"
    android:exported="true"
    android:permission="android.permission.RECEIVE_BOOT_COMPLETED">
    <intent-filter>
        <action android:name="android.intent.action.BOOT_COMPLETED" />
        <action android:name="android.intent.action.QUICKBOOT_POWERON" />
    </intent-filter>
</receiver>

<!-- Add permissions -->
<uses-permission android:name="android.permission.RECEIVE_BOOT_COMPLETED" />
<uses-permission android:name="android.permission.WAKE_LOCK" />
```

## Fix 3: Verify Negative Score Carryover

The negative score system appears to be working correctly based on the code analysis:

1. **DailyScoreCarryoverService.kt** correctly calculates:
   - Positive points: +100 per minute saved
   - Negative points: -50 per minute overtime
   - Net calculation properly handles both scenarios

2. **EnhancedScoreService.ts** properly applies carryover:
   - Checks and processes new day
   - Applies both positive and negative carryover
   - Shows appropriate toast messages

### Add Debug Logging for Verification

Update `src/services/EnhancedScoreService.ts`:

```typescript
private async checkAndApplyCarryover(): Promise<void> {
  try {
    const carryoverApplied = await AsyncStorage.getItem(this.STORAGE_KEYS.CARRYOVER_APPLIED);
    if (carryoverApplied === 'true') {
      console.log('ðŸ“Š [Score] Carryover already applied for today');
      return;
    }

    // Check native carryover
    if (NativeModules.DailyScoreCarryover) {
      try {
        // First ensure end-of-day processing
        await NativeModules.DailyScoreCarryover.checkAndProcessNewDay();
        
        // Get carryover info for debugging
        const info = await NativeModules.DailyScoreCarryover.getCarryoverInfo();
        console.log('ðŸ“Š [Score] Carryover Info:', {
          remainingMinutes: info.remainingTimeMinutes,
          overtimeMinutes: info.overtimeMinutes,
          potentialScore: info.potentialCarryoverScore,
          isPositive: info.isPositive
        });
        
        // Apply carryover score
        const carryoverScore = await NativeModules.DailyScoreCarryover.getTodayStartScore();
        if (carryoverScore !== 0) {
          console.log(`ðŸŽ¯ Applying carryover: ${carryoverScore > 0 ? '+' : ''}${carryoverScore}`);
          
          this.dailyScore = carryoverScore; // Allow negative
          await AsyncStorage.setItem(this.STORAGE_KEYS.CARRYOVER_APPLIED, 'true');
          await this.saveData();
          
          // Show toast with detailed message
          if (NativeModules.ToastModule) {
            const message = carryoverScore > 0
              ? `ðŸŽ‰ Bonus! +${carryoverScore} points from ${Math.abs(info.remainingTimeMinutes)} minutes saved yesterday!`
              : `âš ï¸ Starting with ${Math.abs(carryoverScore)} point penalty from ${info.overtimeMinutes} minutes overtime yesterday`;
            NativeModules.ToastModule.show(message, NativeModules.ToastModule.LONG);
          }
        } else {
          console.log('â„¹ï¸ [Score] No carryover to apply (net zero)');
        }
      } catch (error) {
        console.error('âŒ [Score] Native carryover failed:', error);
        // Fall back to JS implementation...
      }
    }
  } catch (error) {
    console.error('âŒ [Score] Failed to apply carryover:', error);
  }
}
```

## Testing Instructions

### 1. Test Scheduled Notifications
```javascript
// In your app, trigger test notifications:
async function testScheduledNotifications() {
  const now = new Date();
  
  // Test notification in 30 seconds
  const test1 = new Date(now.getTime() + 30000);
  await NotificationService.scheduleOneTimeNotification(
    'test_1',
    test1,
    'ðŸ§ª Test Notification',
    'This is a test of the scheduling system',
    { type: 'test' }
  );
  
  console.log('Test notification scheduled for 30 seconds from now');
}
```

### 2. Test Timer Persistence
```javascript
// Monitor timer service lifecycle
async function monitorTimerHealth() {
  const { ScreenTimeModule } = NativeModules;
  
  setInterval(async () => {
    const isRunning = await ScreenTimeModule.isServiceRunning();
    const state = await ScreenTimeModule.getTimerState();
    
    console.log('Timer Health Check:', {
      serviceRunning: isRunning,
      remainingTime: state.remainingTime,
      uptime: state.serviceUptime,
      lastRestart: state.lastRestartTime
    });
  }, 60000); // Check every minute
}
```

### 3. Test Negative Score Carryover
```javascript
// Force end-of-day processing with overtime
async function testNegativeCarryover() {
  const { DailyScoreCarryover } = NativeModules;
  
  // Get current state
  const info = await DailyScoreCarryover.getCarryoverInfo();
  console.log('Current carryover info:', info);
  
  // Process end of day
  await DailyScoreCarryover.processEndOfDay();
  
  // Check tomorrow's starting score
  const startScore = await DailyScoreCarryover.getTodayStartScore();
  console.log('Tomorrow will start with:', startScore, 'points');
}
```

## Summary

These fixes address:

1. **Scheduled Notifications**: Implemented proper `scheduleOneTimeNotification` in native module with AlarmManager
2. **6-Hour Timer Death**: Added JobScheduler, critical wakeup alarms, and proper wakelock management to keep service alive for 16 hours
3. **Negative Score**: System is working correctly, added debug logging for verification

The key improvements:
- AlarmManager with `setAlarmClock` for critical wakeups that bypass Doze mode
- JobScheduler for periodic service health checks
- Proper wakelock renewal every 9 minutes
- Service auto-restart after 16 hours to prevent system cleanup
- Comprehensive logging for debugging

Deploy these changes and monitor the logs to ensure everything works as expected.